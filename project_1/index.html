<html><head><meta content="text/html; charset=UTF-8" http-equiv="content-type"><style type="text/css">.lst-kix_80pb12mbydq1-7>li:before{content:"\0025cb  "}.lst-kix_80pb12mbydq1-4>li:before{content:"\0025cb  "}.lst-kix_80pb12mbydq1-8>li:before{content:"\0025a0  "}ul.lst-kix_80pb12mbydq1-7{list-style-type:none}ul.lst-kix_80pb12mbydq1-6{list-style-type:none}.lst-kix_80pb12mbydq1-3>li:before{content:"\0025cf  "}ul.lst-kix_80pb12mbydq1-8{list-style-type:none}.lst-kix_80pb12mbydq1-2>li:before{content:"\0025a0  "}ul.lst-kix_80pb12mbydq1-1{list-style-type:none}ul.lst-kix_80pb12mbydq1-0{list-style-type:none}.lst-kix_80pb12mbydq1-1>li:before{content:"\0025cb  "}ul.lst-kix_80pb12mbydq1-3{list-style-type:none}ul.lst-kix_80pb12mbydq1-2{list-style-type:none}ul.lst-kix_80pb12mbydq1-5{list-style-type:none}.lst-kix_80pb12mbydq1-0>li:before{content:"\0025cf  "}ul.lst-kix_80pb12mbydq1-4{list-style-type:none}.lst-kix_80pb12mbydq1-5>li:before{content:"\0025a0  "}.lst-kix_80pb12mbydq1-6>li:before{content:"\0025cf  "}ol{margin:0;padding:0}table td,table th{padding:0}.c0{line-height:1.0;orphans:2;widows:2}.c14{background-color:#ffffff;max-width:468pt;padding:72pt 72pt 72pt 72pt}.c15{color:#1155cc;text-decoration:underline}.c16{color:inherit;text-decoration:inherit}.c8{orphans:2;widows:2}.c4{font-size:14pt;font-weight:bold}.c2{text-indent:36pt;height:11pt}.c7{font-size:10pt}.c6{text-align:center}.c3{height:11pt}.c1{page-break-after:avoid}.c12{height:20pt}.c9{text-indent:36pt}.c11{font-size:16pt}.c13{text-align:right}.c10{font-size:11pt}.c5{font-weight:bold}.title{padding-top:0pt;color:#000000;font-size:26pt;padding-bottom:3pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}.subtitle{padding-top:0pt;color:#666666;font-size:15pt;padding-bottom:16pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}li{color:#000000;font-size:11pt;font-family:"Arial"}p{margin:0;color:#000000;font-size:11pt;font-family:"Arial"}h1{padding-top:20pt;color:#000000;font-size:20pt;padding-bottom:6pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h2{padding-top:18pt;color:#000000;font-size:16pt;padding-bottom:6pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h3{padding-top:16pt;color:#434343;font-size:14pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h4{padding-top:14pt;color:#666666;font-size:12pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h5{padding-top:12pt;color:#666666;font-size:11pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h6{padding-top:12pt;color:#666666;font-size:11pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;font-style:italic;orphans:2;widows:2;text-align:left}</style></head><body class="c14"><p class="c8 c13"><span class="c5">Richard B. Wagner</span></p><p class="c8 c13"><span class="c5">Navdeep Bahia</span></p><p class="c8 c3 c13"><span class="c5"></span></p><p class="c8 c6 c3"><span class="c5"></span></p><p class="c8 c6 c3"><span class="c5"></span></p><p class="c8 c6 c3"><span class="c5"></span></p><p class="c8 c6 c3"><span class="c5"></span></p><p class="c8 c6 c3"><span class="c5"></span></p><p class="c8 c6 c3"><span class="c5"></span></p><p class="c8 c6 c3"><span class="c5"></span></p><p class="c8 c6 c3"><span class="c5"></span></p><p class="c8 c6 c3"><span class="c5"></span></p><p class="c8 c6 c3"><span class="c5"></span></p><p class="c8 c6 c3"><span class="c5"></span></p><p class="c8 c6 c3"><span class="c5"></span></p><p class="c8 c6 c3"><span class="c5"></span></p><p class="c8 c6 c3"><span class="c5"></span></p><p class="c8 c6 c1 title"><a id="h.wzsh73c4tw01" name="h.wzsh73c4tw01"></a><span>CSC 460: Project One</span></p><p class="c8 c6 c1 subtitle"><a id="h.wzsh73c4tw01" name="h.wzsh73c4tw01"></a><span>Implementation of Base and Remote Stations</span></p><p class="c8 c3"><span class="c5"></span></p><p class="c8 c3"><span class="c5"></span></p><p class="c8 c3"><span class="c5"></span></p><p class="c8 c3"><span class="c5"></span></p><p class="c8 c3"><span class="c5"></span></p><p class="c8 c3"><span class="c5"></span></p><p class="c8 c3"><span class="c5"></span></p><p class="c8 c3"><span class="c5"></span></p><p class="c8 c3"><span class="c5"></span></p><p class="c8 c3"><span class="c5"></span></p><p class="c8 c3"><span class="c5"></span></p><p class="c8 c3"><span class="c5"></span></p><p class="c8 c3"><span class="c5"></span></p><p class="c8 c3"><span class="c5"></span></p><p class="c8 c3"><span class="c5"></span></p><h1 class="c8 c1 c12"><a id="h.8a6e7foa61wz" name="h.8a6e7foa61wz"></a></h1><h1 class="c8 c1"><a id="h.h6ydcmta5btf" name="h.h6ydcmta5btf"></a><span>Introduction</span></h1><p class="c0 c3"><span class="c5"></span></p><p class="c0"><span class="c5">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span>The primary purpose of this first project was to familiarize ourselves with techniques involved in the design and implementation of embedded systems. &nbsp;Additionally, we became acquainted with the various pieces of hardware and software that we will be using to create the final product. &nbsp;Particular focus was placed on understanding how the hardware and software interface with one another, as well as the most efficient methods of debugging these connections in the event of an error. &nbsp;The project was split into two sections; Phase 1 involved setting up a single based station consisting of all the main components, while Phase 2 required the assembly of both a based station and a remote station that communicated through two wireless Bluetooth radio modules. &nbsp;</span></p><p class="c0 c3"><span></span></p><p class="c0 c9"><span>The is report describes the entire process behind the implementation of both phases. &nbsp;A list of the hardware used in all configurations of these stations can be found in the section of the same name. &nbsp;The </span><span class="c5">Process and Design </span><span>section goes into detail behind the wiring of the hardware for both phases and provides an explanation of the code that runs the system. &nbsp;Photos of the end results can be found in </span><span class="c5">Images, </span><span>while a link to the Github repository containing all files for this project can be found in the section title </span><span class="c5">Code. </span><span>The </span><span class="c5">Results </span><span>section contains the screenshots from the logic analyzer and further details regarding the outputs of the I/O devices and scheduled tasks. &nbsp;Finally, </span><span class="c5">Debugging </span><span>describes the main problems we ran into and the methods we used to solve them. &nbsp;</span></p><p class="c8 c3"><span class="c11"></span></p><p class="c8 c3"><span class="c11"></span></p><p class="c8 c3"><span class="c11"></span></p><p class="c3 c8"><span class="c11"></span></p><p class="c8 c3"><span class="c11"></span></p><p class="c8 c3"><span class="c11"></span></p><p class="c8 c3"><span class="c11"></span></p><p class="c8 c3"><span class="c11"></span></p><p class="c8 c3"><span class="c11"></span></p><p class="c8 c3"><span class="c11"></span></p><p class="c8 c3"><span class="c11"></span></p><h2 class="c0 c1"><a id="h.hfla6mjbv4na" name="h.hfla6mjbv4na"></a><span>Hardware</span></h2><p class="c0 c3"><span class="c5"></span></p><p class="c0"><span>The following is a list of the hardware used in both phases of the project: </span></p><p class="c0 c3"><span></span></p><p class="c0"><span>2 x Arduino Mega 2560 Microcontrollers</span></p><p class="c0"><span>2 x Bluetooth Radio HC-05/06</span></p><p class="c0"><span>1 x Arduino KY-023 XY-axis Joystick Module</span></p><p class="c0"><span>1 x SG-90 Tower Pro Servo Motor</span></p><p class="c0"><span>1 x KY-008 Arduino Laser Module</span></p><p class="c0"><span>1 x Analog Light Sensor/Photocell</span></p><p class="c0"><span>1 x 2N3904 NPN Power MOSFET Transistor</span></p><p class="c0"><span>1 x I2C LCD Display</span></p><p class="c0"><span>1 x 10 &#13248; Resistor</span></p><p class="c0"><span>1 x 2.2 &#13248; Resistor</span></p><p class="c0"><span>2 x Breadboards </span></p><p class="c0"><span>1 x Switchable Power Supply</span></p><p class="c0"><span>1 x AC Adapter</span></p><h1 class="c0 c1 c12"><a id="h.6ac508qaks35" name="h.6ac508qaks35"></a></h1><h1 class="c0 c1"><a id="h.v4y5mankt4n3" name="h.v4y5mankt4n3"></a><span>Process and Design </span></h1><p class="c0 c3"><span class="c4"></span></p><h2 class="c0 c1"><a id="h.cls762bnumnr" name="h.cls762bnumnr"></a><span>Phase 1: Hardware</span></h2><p class="c0 c3"><span class="c5"></span></p><p class="c0"><span class="c5">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span>The single based station consists of a single Arduino Mega 2560 Microcontroller with a joystick that both controls the movement of the servo motor and the firing of the laser. &nbsp;An attached I2C LCD screen detects the position of the joystick along the x-axis along with the status of the light sensor, i.e. whether or not it is detecting the laser&rsquo;s light. &nbsp;The wiring diagram for the hardware components of this phase is on the following page. &nbsp;We used the breadboard extensively to make pin connections for the sake of making the entire system easier to debug.</span></p><p class="c0 c3"><span></span></p><p class="c8 c6"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 642.67px;"><img alt="" src="images/image00.png" style="width: 624.00px; height: 642.67px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c8 c6"><span class="c7 c5">Figure 1: Wiring Diagram of the Single Based Station</span></p><p class="c8 c3"><span class="c7 c5"></span></p><p class="c8 c3"><span class="c5 c7"></span></p><p class="c8 c9"><span>The code for this system was written using the Arduino Software IDE. This made it much simpler to understand how both the software and the hardware interfaced in order to function smoothly. &nbsp; There are both digital and analog pins on the Arduino board and both types were used in this phase. &nbsp;It was necessary to determine which pieces of hardware would function with which type of pin. &nbsp;As can be seen above the laser, LCD, servo, and the joystick&rsquo;s switch button are all attached to digital pins. &nbsp;The light sensor and the joystick&rsquo;s XY outputs are attached to analog pins. &nbsp;The following snippet of code illustrates how pins were assigned to hardware components.</span></p><p class="c8 c2"><span></span></p><p class="c8 c6 c9"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 332.00px; height: 161.00px;"><img alt="" src="images/image13.png" style="width: 332.00px; height: 161.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c8 c6 c9"><span class="c7 c5">Figure 2: Sample of Pin Setup</span></p><p class="c8 c2 c6"><span class="c7 c5"></span></p><p class="c8 c3"><span></span></p><p class="c8"><span>Other functions of note include analogRead(), &nbsp;analogWrite(), digitalRead(), and digitalWrite() to gather input from the pins and send signals to the pins. &nbsp;The functions found in the Servo and LCD libraries were also used to initialize these components and enable them for I/O. </span></p><p class="c8 c3"><span></span></p><h3 class="c0 c1"><a id="h.bxvt7jbjiz9m" name="h.bxvt7jbjiz9m"></a><span>Phase 1: Code</span></h3><p class="c0 c3"><span class="c5"></span></p><p class="c0 c9"><span>The full code can be found in the </span><span class="c5">Code </span><span>section of the report, in the file named </span><span class="c5">project1_phase1.ino </span><span>found in the </span><span class="c5">project1_phase1 </span><span>folder</span><span class="c5">.</span><span>&nbsp; This section will describe the thought process behind it and highlight some key parts. &nbsp;</span></p><p class="c0 c2"><span></span></p><p class="c0 c9"><span>After all of the required pins have been set up and a servo object is created, all global variables, then the setup code is run once. &nbsp;The servo object is attached to digital pin 9 and centered to 1500 microseconds, a number that was given to us in class. </span></p><p class="c0 c2"><span></span></p><p class="c0 c6 c9"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 223.00px; height: 136.00px;"><img alt="" src="images/image03.png" style="width: 223.00px; height: 136.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c8 c6"><span class="c7 c5">Figure 3: Servo and LCD Setup</span></p><p class="c8 c3"><span></span></p><p class="c8"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Then, the LCD backlight is turned on and the digital pin for the joystick button is set as an input using the pinMode() function, as the laser will be toggled according to whether it is pressed down or not. &nbsp;Digital pin 13 corresponds to the laser and is set as an output since feedback from it is not required for the system to operate. &nbsp;</span></p><p class="c0 c6"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 206.00px; height: 98.00px;"><img alt="" src="images/image09.png" style="width: 206.00px; height: 98.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c0 c6"><span class="c7 c5">Figure 4: Joystick Button and Laser Pin Initialization</span></p><p class="c0 c6 c3"><span class="c7 c5"></span></p><p class="c0 c3"><span></span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Now, we turn to the loop. &nbsp;The laser begins in the OFF position and a variable takes in a reading from the joystick switch. &nbsp;This is followed by a very simple debouncing format that uses a timer combined with the previous and current states of the button and laser. &nbsp;This is to ensure that there are no missed button clicks or lag in the way the laser turns off and on. &nbsp;The loop also takes a reading from the light sensor in every iteration. &nbsp;If the reading exceeds a certain threshold, a qualitative measure of 800 in this case which was determined by AdaFruit, then it will trigger the targetHit() function. &nbsp;This function is located outside the loop and sends a message to the LCD to display the status of the sensor and to flash the backlight on and off. &nbsp;Lastly, the loop takes a reading from the X-axis output of the joystick and displays the value on the LCD. &nbsp;The input from the joystick ranges from the values 0 to 1023, so they must be scaled appropriately to the values the are in the safe range (1000-2000) for the servo motor. &nbsp;This is accomplished using the map() function and the result is passed on the writeMicroseconds() function to safely move the motor position. &nbsp;There is a small delay (42 milliseconds) after this occurs to ensure smoother movement. &nbsp;</span></p><p class="c0 c3"><span></span></p><p class="c0 c6"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 571.00px; height: 185.00px;"><img alt="" src="images/image05.png" style="width: 571.00px; height: 185.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c0 c6"><span class="c7 c5">Figure 5: Servo Movement</span></p><p class="c0 c6 c3"><span class="c7 c5"></span></p><h3 class="c0 c1"><a id="h.og7kasf2ok96" name="h.og7kasf2ok96"></a><span>Phase 2: Hardware</span></h3><p class="c0 c3"><span></span></p><p class="c0 c9"><span>Assembling both a based station and a remote station required using all of the parts listed in the </span><span class="c5">Hardware</span><span>&nbsp;section of the report. &nbsp;The based station consists of an Arduino Mega 2560 Microcontroller with a wireless Bluetooth radio module to communicate with the remote station. &nbsp;It also has the joystick to control the movement of the servo motor and firing of the laser, the light sensor, and the LCD display which displays the position of the joystick and the status of the light sensor. &nbsp;The wiring diagram for this station can be found on the next page. &nbsp;</span></p><p class="c0 c3"><span></span></p><p class="c8"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 564.00px;"><img alt="" src="images/image16.png" style="width: 624.00px; height: 564.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c8 c6"><span class="c7 c5">Figure 6: Wiring Diagram for the Based Station </span></p><p class="c8 c3"><span class="c5"></span></p><p class="c8 c2"><span></span></p><p class="c8 c9"><span>The remote station is composed of another Arduino board and Bluetooth module, the transistor, the laser and the servo motor. &nbsp;The Bluetooth module receives commands from the based station which turn the laser on/off and control the position of the servo motor. &nbsp;The wiring diagram for this station is below. &nbsp;</span></p><p class="c8 c3"><span></span></p><p class="c8 c3"><span></span></p><p class="c8 c3"><span></span></p><p class="c8 c3"><span></span></p><p class="c8 c3"><span></span></p><p class="c8 c3"><span></span></p><p class="c8"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 617.33px;"><img alt="" src="images/image17.png" style="width: 624.00px; height: 617.33px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c8 c6"><span class="c7 c5">Figure 7: Wiring Diagram for Remote Station</span></p><p class="c0 c3"><span class="c5"></span></p><p class="c0 c3"><span class="c5"></span></p><h3 class="c0 c1"><a id="h.t7hn0n1ac4k9" name="h.t7hn0n1ac4k9"></a><span>Phase 2: Code</span></h3><p class="c0 c3"><span class="c5"></span></p><p class="c0 c9"><span>One of the requirements of this phase was to make use of the Time-Triggered Scheduler code that was provided through the course website. &nbsp;Each station has its own code; the code for the based station can be found in the file </span><span class="c5">main_controller.ino, </span><span>while the code for the remote station can be found in the file </span><span class="c5">main_attacker.ino. &nbsp;</span><span>Both of these files are found in the folders of the same name. &nbsp;Again, this section will highlight the thought process behind the design of this code and point out a few main snippets of code. </span></p><p class="c0 c2"><span></span></p><p class="c0 c9"><span>We begin with the based station. &nbsp;First the pins for the joystick, LCD, and light sensor are initialized in the same manner as in Phase 1. &nbsp;This is followed by the list of tasks and asynchronous events that will trigger once the scheduler is set up. &nbsp;We will come back to those and jump to the setup() function. &nbsp;Serial communication is begun on both Serial and Serial1 to facilitate communication between the two Bluetooth modules. After this, LCD set-up is completed and the screen is ready to display the position of joystick along the X-axis. &nbsp;Then the switch button is set to act as an internal pullup resistor. &nbsp;An explanation is provided in the </span><span class="c5">Debugging </span><span>section. &nbsp;An ambient light variable is set to measure the light in the room to make the sensor more sensitive. &nbsp;Next, the scheduler is initialized and then the scheduled tasks are set-up. &nbsp;In the controller we only have two scheduled tasks, </span><span class="c5">whileHIt </span><span>and </span><span class="c5">sendState, </span><span>both of which have no start delay and will begin as soon as set-up is complete. &nbsp;We set their periods to 10 milliseconds, which is a fairly small amount of time but works well and the system still runs smoothly.</span></p><p class="c0 c2"><span></span></p><p class="c0 c6 c9"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 283.00px; height: 75.00px;"><img alt="" src="images/image14.png" style="width: 283.00px; height: 75.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c0 c6 c9"><span class="c7 c5">Figure 8: Scheduler Initialization for Based Station</span></p><p class="c0 c3"><span class="c4"></span></p><p class="c0 c3"><span></span></p><p class="c0"><span>The loop() function is next, but we have no idle tasks scheduled for this station so it remains empty apart from the default code. &nbsp;</span></p><p class="c0 c3"><span></span></p><p class="c0"><span>The scheduled task </span><span class="c5">sendState(), </span><span>sends a byte of data to the remote station from the Bluetooth describing the state of the joystick&rsquo;s X-axis position and that of the switch button. &nbsp;The value read in from</span><span class="c5">&nbsp;</span><span>the &nbsp;joystick button digital pin is bit-shifted by 7, while the input from the analog pin associated with the X-axis is mapped using the same function as in Phase 1 but to a range that makes sense for transmission. &nbsp;These two values are then added together and sent along the Serial connection. &nbsp;</span></p><p class="c0 c3"><span></span></p><p class="c0 c6"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 410.00px; height: 102.00px;"><img alt="" src="images/image04.png" style="width: 410.00px; height: 102.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c0 c6"><span class="c7 c5">Figure 9: Bluetooth Encoding</span></p><p class="c0 c3"><span></span></p><p class="c0 c3"><span></span></p><p class="c0"><span>The LCD is then updated with the position value.</span></p><p class="c0 c3"><span></span></p><p class="c0"><span>The </span><span class="c5">whileHit() </span><span>task is responsible for detecting light from the light sensor, using the </span><span class="c5">isHit() </span><span>function, and then updating the LCD with its state. &nbsp;If the task detects that the laser button has been pressed but the sensor is not registering an input above a certain threshold, based on the ambient light in the room, it calls on the non-scheduled </span><span class="c5">printLaserState() </span><span>function to display the &ldquo;Missed Target&rdquo; message. &nbsp;If the sensor does pick up the required increase in light </span><span class="c5">targetHIt()</span><span>, another non-scheduled function, is called which flashes the LCD backlight on and off and displays the &ldquo;HIT&rdquo; message. </span></p><p class="c0 c3"><span></span></p><p class="c0 c3"><span></span></p><p class="c0 c6"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 361.00px; height: 379.00px;"><img alt="" src="images/image06.png" style="width: 361.00px; height: 379.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c0 c6"><span class="c7 c5">Figure 10: whileHit() task</span></p><p class="c0 c6 c3"><span class="c7 c5"></span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p><p class="c0 c9"><span>Moving on to the remote station. &nbsp;The digital pins for the laser and the servo motor are initialized at the start of the file, </span><span class="c5">main_attacker.ino, </span><span>but we are skipping ahead to the bottom of the file to start our explanation. &nbsp;Again, there are no idle tasks set for this station so that function and the loop() remain empty. &nbsp;The setup() function begins by initializing the servo object and centering the motor&rsquo;s position. &nbsp;This is followed up the laser and Bluetooth communication being initialized. &nbsp;Next, the scheduler is initialized and then the single scheduled task for this station is setup. &nbsp;</span><span class="c5">Pole_serial </span><span>has no start delay and will begin as soon as set-up is complete and is scheduled with a period of 10 milliseconds. </span></p><p class="c0 c2"><span></span></p><p class="c0 c2"><span></span></p><p class="c0 c6 c9"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 290.00px; height: 63.00px;"><img alt="" src="images/image15.png" style="width: 290.00px; height: 63.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c0 c6 c9"><span class="c7 c5">Figure 11: Scheduler Initialization for Remote Station</span></p><p class="c0 c2 c6"><span class="c7 c5"></span></p><p class="c0 c2"><span class="c5"></span></p><p class="c0 c9"><span class="c5">Pole_serial </span><span>checks the availability of the serial buffer. &nbsp;The encoded byte sent from the based station is read and parsed using bitmasks. The highest order bit is used to update the ON/OFF state of the laser. &nbsp;The next seven bits are used to update the servo position. &nbsp;We also made use of relative positioning to ensure smoother movement of the servo motor. &nbsp;As can be seen below, the input from the received byte is mapped to the range that is safe for the servo. &nbsp;This range is set to &nbsp;-15 to +15 microseconds, the global constant SG91R_MAX_ACCELERATION found in </span><span class="c5">util.h, </span><span>&nbsp;to get a better rate of acceleration and reduce the amount of jerky movement. &nbsp;This mapped value is added to the global variable servoVal, which is then used up the non-scheduled function update_actuator_states().</span></p><p class="c0 c2"><span></span></p><p class="c0 c2"><span></span></p><p class="c0 c6 c9"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 326.67px;"><img alt="" src="images/image01.png" style="width: 624.00px; height: 326.67px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c0 c6 c9"><span class="c7 c5">Figure 12: Pole Serial Scheduled Task</span></p><p class="c0 c2 c6"><span class="c7 c5"></span></p><p class="c0 c2"><span></span></p><p class="c0 c9"><span>This function updates both the laser and the servo. &nbsp;The code is below and as can be seen the current servoVal is compared to the leftmost safe position for the servo, 1000 microseconds, and if it is less than this value it is re-evaluated to be equal to 1000 microseconds to make sure the servo doesn&rsquo;t break by going out of range. &nbsp;The same process is applied to the rightmost position of the servo at 2000 microseconds. &nbsp;Once these checks are complete, the servoVal is written to the servo object and the laser is turned off or on depending on the value found in the received byte from the based station. </span></p><p class="c0 c2"><span></span></p><p class="c0 c2 c6"><span class="c7 c5"></span></p><p class="c0 c6"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 540.00px; height: 159.00px;"><img alt="" src="images/image08.png" style="width: 540.00px; height: 159.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c0 c6"><span class="c7 c5">Figure 13: Update_actuator_states Function</span></p><h1 class="c0 c1 c12"><a id="h.pfk6mlnp0ts1" name="h.pfk6mlnp0ts1"></a></h1><h1 class="c0 c1 c12"><a id="h.fwjbvzdtiteh" name="h.fwjbvzdtiteh"></a></h1><h1 class="c0 c1"><a id="h.495hbqup61u" name="h.495hbqup61u"></a><span>Images</span></h1><h2 class="c0 c1"><a id="h.q17bbes6rzgv" name="h.q17bbes6rzgv"></a><span>Phase 1</span></h2><h2 class="c0 c1 c6"><a id="h.b074s02dilw6" name="h.b074s02dilw6"></a><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 350.67px;"><img alt="" src="images/image10.jpg" style="width: 624.00px; height: 350.67px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></h2><p class="c0 c6"><span class="c7 c5">Figure 14: Image of Single Based Station</span></p><h2 class="c0 c1"><a id="h.2anhsfym8t81" name="h.2anhsfym8t81"></a><span>Phase 2</span></h2><p class="c8"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 468.00px;"><img alt="" src="images/image18.jpg" style="width: 624.00px; height: 468.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c0 c6"><span class="c7 c5">Figure 15: Image of Remote Station</span></p><p class="c0 c3"><span class="c5"></span></p><p class="c8"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 468.00px;"><img alt="" src="images/image12.jpg" style="width: 624.00px; height: 468.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c8 c6"><span class="c7 c5">Figure 16: Image of Based Station</span></p><p class="c0 c3"><span class="c4"></span></p><p class="c0 c3"><span class="c4"></span></p><h1 class="c0 c1"><a id="h.apc743h40jn3" name="h.apc743h40jn3"></a><span>Code</span></h1><p class="c0 c3"><span class="c4"></span></p><p class="c0 c9"><span>This is a link to the Github repository we set up for the project. &nbsp;The code that was described in previous sections can be found in the folders: </span><span class="c5">project1_phase1, main_attacker, main_controller. </span></p><p class="c0 c2"><span></span></p><p class="c0"><span class="c15"><a class="c16" href="https://www.google.com/url?q=https://github.com/breckwagner/CSC460/tree/master/project_1&amp;sa=D&amp;ust=1454712924031000&amp;usg=AFQjCNHVyPswXgmnyCGhAE2rlaNUgP_xsw">https://github.com/breckwagner/CSC460/tree/master/project_1</a></span></p><p class="c0 c3"><span class="c4"></span></p><h1 class="c0 c1 c12"><a id="h.9eymqflwxbip" name="h.9eymqflwxbip"></a></h1><h1 class="c0 c1"><a id="h.n5s1l8b5y951" name="h.n5s1l8b5y951"></a><span>Results </span></h1><p class="c0 c3"><span></span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;We successfully demonstrated the functionality of both phases to our lab instructor. &nbsp;The results from the logic analyzer for Phase 2 can be found on the next page. &nbsp;</span></p><h3 class="c8 c1"><a id="h.3wmjy4o0ozuw" name="h.3wmjy4o0ozuw"></a><span>S</span><span>creenshots of Logic Analyzer</span></h3><p class="c8"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 158.67px;"><img alt="" src="images/image02.png" style="width: 624.00px; height: 158.67px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c8 c6"><span class="c7 c5">Figure 17: Logic of Atmega2560 with the bluetooth/laser/servo calculations being processed in each cycle (channel 0)</span></p><p class="c8"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 158.67px;"><img alt="" src="images/image11.png" style="width: 624.00px; height: 158.67px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c8 c6"><span class="c7 c5">Figure 18: Logic of Atmega2560 with the bluetooth/laser (on/off) processing on channel 0 and photocell polling on channel 2</span></p><p class="c0 c3"><span class="c5"></span></p><h2 class="c8 c1"><a id="h.ebl3xkl2s3f4" name="h.ebl3xkl2s3f4"></a><span>Results from Logic Analyzer</span></h2><p class="c8 c3"><span class="c5"></span></p><p class="c8"><span class="c5">Expected vs. Actual Timing Requirements</span></p><p class="c8 c3"><span></span></p><p class="c8"><span>The based station contained two scheduled tasks meant to run every 10 milliseconds. &nbsp;The remote station had a single scheduled task that was set to run every 10 milliseconds. &nbsp;In actuality, these tasks did run every 10 milliseconds, until the LCD display was being updated using the laser status. </span></p><h3 class="c8 c1"><a id="h.tehzmixxzy2k" name="h.tehzmixxzy2k"></a><span>The Duty Cycle</span></h3><p class="c0 c3"><span class="c5"></span></p><p class="c0"><span>On the board connected to the laser and servo, the duty cycle is consistently near 0.25% on. On the board connected to the LCD display, photosensor, and 2 axis thumbstick, the duty cycle is more complicated. For one thing, the LCD update sequence we use is not asynchronous and causes huge amounts of delay. for this reason, we avoid updating the display whenever possible. When the display is not being updated, the duty cycle is consistently around 3%. When the display needs to be update, the duty cycle shoots up to around 50%. The reason for this is because in the version of the code that we used to analyze the logic and CPU timing we sample at 100Hz. In a later version, we sample at much lower rates and extrapolate values to mitigate this. </span></p><p class="c0 c3"><span class="c4"></span></p><h1 class="c0 c1"><a id="h.hzhkr4yhqtzc" name="h.hzhkr4yhqtzc"></a><span>Debugging</span></h1><p class="c0"><span>&nbsp;</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p><p class="c0 c9"><span>We did run into a few problems through the creation of this project and we&rsquo;ve detailed them, along with their solutions, here. &nbsp;The first major problem we ran into was a simple issue of faulty wiring which was easily solved by changing the wires we were using, however determining that this was the problem took a significant amount of time. &nbsp;</span></p><p class="c0 c3"><span></span></p><p class="c0 c9"><span>Most of the problems we ran into happened while implementing Phase 2 and were primarily a result of the communication between the two Bluetooth modules, or lack thereof. &nbsp;These issues were resolved by tweaking the way the was data being sent in our code until we ended up with the encoding process that is in our final result and detailed in previous sections of the report. &nbsp; A hardware issue was discovered after we encountered floating values from the switch button, often by simply moving our hands over the board. &nbsp;We added an internal resistor to the pin associated with the switch button to counteract the effects of this static. &nbsp;</span></p><p class="c0 c2"><span></span></p><p class="c0 c6 c9"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 384.00px; height: 39.00px;"><img alt="" src="images/image07.png" style="width: 384.00px; height: 39.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c0 c6 c9"><span class="c7 c5">Figure 19: Pull-Up Resistor Code</span></p></body></html>