<html><head><meta content="text/html; charset=UTF-8" http-equiv="content-type"><style type="text/css">ul.lst-kix_wycsgjkbpjh6-6{list-style-type:none}ul.lst-kix_wycsgjkbpjh6-5{list-style-type:none}ul.lst-kix_wycsgjkbpjh6-8{list-style-type:none}ul.lst-kix_wycsgjkbpjh6-7{list-style-type:none}ul.lst-kix_wycsgjkbpjh6-2{list-style-type:none}ul.lst-kix_wycsgjkbpjh6-1{list-style-type:none}.lst-kix_wycsgjkbpjh6-0>li:before{content:"\0025cf  "}ul.lst-kix_wycsgjkbpjh6-4{list-style-type:none}ul.lst-kix_wycsgjkbpjh6-3{list-style-type:none}.lst-kix_wycsgjkbpjh6-6>li:before{content:"\0025cf  "}.lst-kix_wycsgjkbpjh6-8>li:before{content:"\0025a0  "}ul.lst-kix_wycsgjkbpjh6-0{list-style-type:none}.lst-kix_wycsgjkbpjh6-7>li:before{content:"\0025cb  "}.lst-kix_wycsgjkbpjh6-3>li:before{content:"\0025cf  "}.lst-kix_wycsgjkbpjh6-2>li:before{content:"\0025a0  "}.lst-kix_wycsgjkbpjh6-4>li:before{content:"\0025cb  "}.lst-kix_wycsgjkbpjh6-1>li:before{content:"\0025cb  "}.lst-kix_wycsgjkbpjh6-5>li:before{content:"\0025a0  "}ol{margin:0;padding:0}table td,table th{padding:0}.c12{background-color:#ffffff;max-width:468pt;padding:72pt 72pt 72pt 72pt}.c7{padding-bottom:0pt;line-height:1.38;text-align:right}.c10{padding:0;margin:0}.c1{orphans:2;widows:2}.c9{margin-left:36pt;padding-left:0pt}.c14{color:inherit;text-decoration:inherit}.c8{color:#1155cc;text-decoration:underline}.c3{text-align:center}.c11{height:20pt}.c6{page-break-after:avoid}.c16{font-size:20pt}.c2{height:11pt}.c5{font-size:10pt}.c15{font-size:11pt}.c0{font-weight:bold}.c4{text-indent:36pt}.c13{text-align:right}.title{padding-top:0pt;color:#000000;font-size:26pt;padding-bottom:3pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}.subtitle{padding-top:0pt;color:#666666;font-size:15pt;padding-bottom:16pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}li{color:#000000;font-size:11pt;font-family:"Arial"}p{margin:0;color:#000000;font-size:11pt;font-family:"Arial"}h1{padding-top:20pt;color:#000000;font-size:20pt;padding-bottom:6pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h2{padding-top:18pt;color:#000000;font-size:16pt;padding-bottom:6pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h3{padding-top:16pt;color:#434343;font-size:14pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h4{padding-top:14pt;color:#666666;font-size:12pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h5{padding-top:12pt;color:#666666;font-size:11pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h6{padding-top:12pt;color:#666666;font-size:11pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;font-style:italic;orphans:2;widows:2;text-align:left}</style></head><body class="c12"><p class="c7 c1 c6 title" id="h.26618f1gf6kv"><span class="c15">Richard B. Wagner</span></p><p class="c1 c6 c7 title" id="h.i85vylfpzv9q"><span class="c15">Navdeep Bahia</span></p><p class="c1 c6 c2 c13 title" id="h.26618f1gf6kv-1"><span></span></p><p class="c1 c3 c6 c2 title" id="h.gahq9bbgue5v"><span></span></p><p class="c1 c3 c2 c6 title" id="h.phakorq65uve"><span></span></p><p class="c1 c3 c6 c2 title" id="h.lq1xj0k10hd"><span></span></p><p class="c1 c3 c6 c2 title" id="h.62s4h670o8n5"><span></span></p><p class="c1 c3 c6 c2 title" id="h.5mgofy2y7vv3"><span></span></p><p class="c1 c3 c6 title" id="h.8o9sbnrt5ht7"><span>CSC 460: Project Two</span></p><p class="c1 c3 c6 subtitle" id="h.ojc91p4oo9t7"><span>Implementation of RTOS</span></p><p class="c1 c2"><span></span></p><p class="c1 c2"><span></span></p><p class="c1 c2"><span></span></p><p class="c1 c2"><span></span></p><p class="c1 c2"><span></span></p><p class="c1 c2"><span></span></p><p class="c1 c2"><span></span></p><p class="c1 c2"><span></span></p><p class="c1 c2"><span></span></p><p class="c1 c2"><span></span></p><p class="c1 c2"><span></span></p><p class="c1 c2"><span></span></p><p class="c1 c2"><span></span></p><p class="c1 c2"><span></span></p><p class="c1 c2"><span></span></p><p class="c1 c2"><span></span></p><p class="c1 c2"><span></span></p><p class="c1 c2"><span></span></p><p class="c1 c2"><span></span></p><p class="c1 c2"><span></span></p><h1 class="c1 c6" id="h.q0ioq9nn3xtu"><span>1. Introduction </span></h1><h2 class="c1 c6" id="h.59pzmdo4icrk"><span>1.1 Objective</span></h2><p class="c1 c2 c4"><span></span></p><p class="c1 c4"><span>The primary purpose of this project was to create a functioning Real-Time Operating System (RTOS). &nbsp;The RTOS was meant to be a priority based pre-emptive and multi-threading system with mutexes, events, priority inheritance, and timeouts. &nbsp;Another objective was to become acquainted with the design and debugging process of these types of systems. &nbsp;The implementation consists of files representing the operating system, files that comprise the kernel functions, and various other support files containing useful data structures. &nbsp;</span></p><h2 class="c1 c6" id="h.oirbwrsqd4f9"><span>1.2 Scope of Report</span></h2><p class="c1 c2"><span></span></p><p class="c1"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This report details the entire process behind designing and implementing the RTOS as described in the previous section. &nbsp;There is information regarding the hardware that the RTOS is deployed on and the instruments used to test and debug. &nbsp;The </span><span class="c0">Process and Design </span><span>section provides the various diagrams (block diagrams, state diagrams, etc) that lay out the thought process behind how the overall system was envisioned to run. &nbsp;Additionally, there are subsections with information regarding the implementation, or at least attempted implementation, of each of the functions needed to meet the project requirements. &nbsp;</span><span class="c0">Testing and Profiling </span><span>describes the methods of creating test cases to determine the functionality of the system and the test cases themselves. &nbsp;</span><span class="c0">Debugging </span><span>details how errors were discovered and resolved in the code. &nbsp;</span><span class="c0">Results </span><span>contains the final results of the test cases provided in the project description, including output from the Logic Analyzer. &nbsp;</span><span class="c0">Obstacles </span><span>lists the difficulties faced during implementation and possible solutions if there weren&rsquo;t time constraints. &nbsp;</span><span class="c0">Code </span><span>contains a link to a GitHub repository as well as instructions on how to run the RTOS code. &nbsp;</span><span class="c0">&nbsp;</span><span>&nbsp; </span><span>&nbsp; </span></p><h2 class="c1 c6" id="h.dv6bwu2bldsa"><span>1.3 Hardware</span></h2><p class="c1"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The RTOS is designed to work on the Arduino Mega 2560 microcontroller. &nbsp;This was used in conjunction with various LEDs to represent the tasks being run. &nbsp;To test and debug the code, a Logic Analyzer and the Seale Logic Software were used. &nbsp;</span></p><h1 class="c1 c11 c6" id="h.sye18bn1uy43"><span></span></h1><h1 class="c1 c6" id="h.f58txknh8e9k"><span>2. Process and Design</span></h1><p class="c1 c2"><span></span></p><h2 class="c1 c6" id="h.gx1y7ko0zg11"><span>2.1 RTOS Booting and Context Switching</span></h2><p class="c1 c2"><span></span></p><p class="c1"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The system boots by calling </span><span class="c0">OS_Init(). &nbsp;</span><span>This function initializes the queues for the sleep function and the data structure referred to as the </span><span class="c0">running_queue. &nbsp;</span><span>Space for the process descriptors for the maximum number of threads allowed by the system and the maximum number of mutexes is also allocated at this point. &nbsp;</span><span class="c0">&nbsp;</span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1 c3"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 336.50px; height: 285.49px;"><img alt="" src="images/image14.png" style="width: 336.50px; height: 285.49px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1 c3"><span class="c0 c5">Figure 1: Code for OS_Init()</span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1 c2"><span></span></p><p class="c1"><span>The next aspect to initialized are the timers that will be used by the various interrupts that the system as been designed to handle. &nbsp;After this, a few tasks are created before the RTOS is started up by the </span><span class="c0">OS_Start() </span><span>function. &nbsp;</span></p><p class="c1 c2"><span></span></p><p class="c1 c2"><span></span></p><p class="c1 c2"><span></span></p><h3 class="c1 c6" id="h.udnp7ez7kqp9"><span>2.1.1 Context Switching</span></h3><p class="c1"><span>&nbsp; &nbsp;</span></p><p class="c1"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;On multithreaded systems, each thread executes as if it is the sole process being run by the processor. &nbsp;The thread doesn&rsquo;t interact with other threads, use any results produced by them, or otherwise care about their existence. &nbsp;The threads consist of both code and context. &nbsp;Context is the collection of physically shared but logically independent resources belonging to a process on a system. &nbsp;It is used to keep track of a process&rsquo; state throughout execution, including times when it is suspended or resumed. &nbsp;Examples of context include thread descriptors, register values, the state of interrupts, etc. &nbsp;The specific pieces of context that the Arduino Mega 2560 keeps track of are:</span></p><p class="c1 c2"><span></span></p><ul class="c10 lst-kix_wycsgjkbpjh6-0 start"><li class="c1 c9"><span>The stack register or SREG, which keeps track of the status of the processor</span></li><li class="c1 c9"><span>The stack pointers SPH and SPL. &nbsp;Stack pointers keep track of the last address in which data is to be retrieved or point to the next address that contains a spot for data to be stored. &nbsp;The Arduino Mega requires the two stack pointers as the amount of memory it contains exceeds the 8-bits that could be accessed by a single stack pointer. SPH stands for &ldquo;Stack Pointer High&rdquo; &nbsp;and SPL is &ldquo;Stack Pointer Low&rdquo;. &nbsp;</span></li><li class="c1 c9"><span>EIND, extended indirect register, is an additional register intended to facilitate an Extended Indirect Jump to access memory addresses that can&rsquo;t be reached by the combination of the two stack pointers. &nbsp;More details on this are given below.</span></li><li class="c1 c9"><span>General purpose registers r0 - r31.</span></li><li class="c1 c9"><span>The program counter that keeps track of which instruction the process was suspended or interrupted at, so the CPU knows to resume execution at that line of code.</span></li></ul><p class="c1 c2"><span></span></p><p class="c1 c2"><span></span></p><p class="c1"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Since an Arduino Mega 2560 microcontroller was used for this project, the RTOS that was designed utilizes embedded context-switching that requires the 17-bit address problem be resolved in order for it to work correctly. &nbsp; The 17-bit address problem stems from the fact that the Arduino Mega 2560 possesses a 256K program memory that requires more than 16 bits in order to be able to access all possible memory locations. &nbsp;Any address greater than 128K is accessed by concatenating SPH and SPL with the EIND register to form three-byte function pointers. &nbsp;This means that, aside from the extra register that must be tracked, the code must be modified such that it always pops three bytes off the stack when trying to create return addresses for the program counter to resume execution. &nbsp;This problem was resolved by adding lines of code to the file </span><span class="c0">cswitch.S. &nbsp;</span><span>The location of EIND was added, along with lines ensuring that the values stored in it were both pushed and popped of the stack in the correct order.</span></p><p class="c1 c2"><span></span></p><p class="c1 c2"><span></span></p><p class="c1 c3"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 279.31px; height: 91.33px;"><img alt="" src="images/image13.png" style="width: 279.31px; height: 91.33px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1 c3"><span class="c5 c0">Figure 2: Addition of EIND Register</span></p><p class="c1 c3 c2"><span class="c5 c0"></span></p><p class="c1 c3"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 288.64px; height: 179.50px;"><img alt="" src="images/image04.png" style="width: 288.64px; height: 179.50px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1 c3"><span class="c5 c0">Figure 3: Value in EIND Being Pushed and Popped From Stack</span></p><p class="c1 c2"><span></span></p><p class="c1 c2"><span></span></p><p class="c1"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Context switching occurs when the processor switches from executing on task to another. &nbsp;More thoroughly, the kernel suspends a running process and saves its context, meaning the state of the CPU including the contents of registers and the locations of pointers. &nbsp;Once this is done, the kernel retrieves the context for the next process it wants to run and stores these values in the CPU&rsquo;s registers. &nbsp;It then begins or resumes the execution of this next process from the line of code pointed at by the program counter.</span></p><p class="c1 c2"><span></span></p><p class="c1 c4"><span>In the RTOS, the context saving and then switching is executed by the functions </span><span class="c0">Enter_Kernel()</span><span>&nbsp;and </span><span class="c0">Exit_Kernel() </span><span>in the cswitch.S file. &nbsp;Enter_Kernel is called by a function, which then stores the running process&rsquo; context and switches to operate within the kernel&rsquo;s stack. &nbsp;The kernel takes over at this point and once it ready to move on to the next process, it call on Exit_Kernel where the context for the next process is restored to the CPU&rsquo;s registers.</span></p><p class="c1 c2 c4"><span></span></p><h3 class="c1 c6" id="h.33xi9w50dczu"><span>2.1.2 Control Flow</span></h3><p class="c1 c2 c4"><span></span></p><p class="c1 c4"><span>The diagram below is a visual representation of how the main functions in the RTOS are meant to interact with one another. &nbsp;The many of the kernel request terms are found in the file </span><span class="c0">kernel.h </span><span>and can be seen in </span><span class="c0">Figure 5 </span><span>below. &nbsp;The ones associated with events are found in the function </span><span class="c0">next_kernel_request() </span><span>in the file </span><span class="c0">os.c. </span></p><p class="c1 c2 c4"><span class="c0"></span></p><p class="c1 c2 c4"><span class="c0"></span></p><p class="c1 c2 c4"><span class="c0"></span></p><p class="c1 c3 c4"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 541.01px; height: 759.50px;"><img alt="" src="images/image02.png" style="width: 541.01px; height: 759.50px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1 c3 c4"><span class="c5 c0">Figure 5: Control Flow Diagram</span></p><p class="c1 c2"><span></span></p><p class="c1 c2"><span></span></p><h2 class="c1 c6" id="h.8id5mnogjyj"><span>2.2 Tasks</span></h2><p class="c1 c2"><span></span></p><p class="c1 c2"><span></span></p><p class="c1 c3"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 299.38px; height: 375.50px;"><img alt="" src="images/image00.png" style="width: 299.38px; height: 375.50px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1 c3"><span class="c5 c0">Figure 5: Process Structs and Enums</span></p><h3 class="c1 c6" id="h.kx8fc4r5d7su"><span>2.2.1 Task_Create()</span></h3><p class="c1 c2"><span></span></p><p class="c1 c4"><span>Whenever Task_Create is invoked, a kernel request is made and the kernel_create_task(voidfuncptr f) which calls the kernel_create_task_at(</span><span>volatile </span><span>ProcessDescriptor *process, voidfuncptr function). It is responsible for setting up the program counter and initializing the process descriptor. </span></p><p class="c1 c2"><span></span></p><h3 class="c1 c6" id="h.ck9l3xvbwp7w"><span>2.2.2 Task_Terminate()</span></h3><p class="c1 c2"><span></span></p><p class="c1 c4"><span>The Task_Terminat function is very simple. When called explicitly or when the calling function returns, Task_Terminate makes a request to the kernel to terminate which then sets the process descriptor of the function to DEAD and calls dispatch.</span></p><p class="c1 c2"><span></span></p><h3 class="c1 c6" id="h.ya55g4l9cc6y"><span>2.2.3 Task_GetArg()</span></h3><p class="c1 c2"><span></span></p><p class="c1 c4"><span>The Task_GetArg function just returns the current_process-&gt;argument from the process descriptors struct. The argument is set in the Task_Create routine.</span></p><p class="c1 c2"><span></span></p><h3 class="c1 c6" id="h.uditc6dzr2ri"><span>2.2.4 Task_Yield()</span></h3><p class="c1 c2"><span></span></p><p class="c1"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This function sets the state of the current process to the state NEXT. &nbsp;It then enters the kernel and enter the function </span><span class="c0">next_kernel_request() </span><span>from which it triggers the </span><span class="c0">dispatch() </span><span>function. &nbsp;After leaving dispatch, next_kernel_request is returned to where the </span><span class="c0">Exit_Kernel() </span><span>function is signalled and the process counter is updated. &nbsp;</span></p><p class="c1 c2"><span></span></p><p class="c1 c2"><span></span></p><p class="c1 c3"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 444.50px; height: 243.55px;"><img alt="" src="images/image10.png" style="width: 444.50px; height: 243.55px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1 c3"><span class="c5 c0">Figure 6: Task Suspend/Resume State Diagram</span></p><p class="c1 c3 c2"><span class="c5 c0"></span></p><h3 class="c1 c6" id="h.ocz2gqk5v1cm"><span>2.2.5 Task_Suspend(pid)</span></h3><p class="c1 c2"><span></span></p><p class="c1 c4"><span>Task_Suspend first checks to see if a process is already suspended and if not calls dequeue on the process descriptor pointer which removes it from the running_queue. It finally sets the suspended flag to true.</span></p><p class="c1 c2 c4"><span></span></p><h3 class="c1 c6" id="h.j90qceoaozrv"><span>2.2.6 Task_Resume(pid)</span></h3><p class="c1 c2"><span></span></p><p class="c1 c4"><span>Task_Resume first checks to see if a process is already suspended and if yes it calls enqueue on the process descriptor pointer which adds it to the running_queue. It finally sets the suspended flag to false.</span></p><p class="c1 c2"><span></span></p><p class="c1 c2"><span></span></p><h3 class="c1 c6" id="h.sscy8lhav88o"><span>2.2.7 Task_Sleep(t)</span></h3><p class="c1 c2"><span></span></p><p class="c1 c4"><span>Task sleep suspends a task for time t. When it is called, the task it is called on enters the sleep_queue which is a linked list of the sleeping processes where it waits for the ISR to be called. The expires attribute is assigned the aggregate of the global clock and the time t. The ISR checks if global clock surpasses the expires attribute and pops the element out of the queue and enqueues it in the running_queue.</span></p><p class="c1 c2"><span></span></p><p class="c1 c2"><span></span></p><p class="c1 c3"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 345.00px; height: 309.02px;"><img alt="" src="images/image11.png" style="width: 345.00px; height: 309.02px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1 c3"><span class="c5 c0">Figure 7: Code for task_sleep</span></p><p class="c1 c3 c2"><span class="c5 c0"></span></p><h2 class="c1 c6" id="h.gqc5pk8j6nn2"><span>2.3 Priority Inheritance</span></h2><p class="c1 c2"><span></span></p><p class="c1 c4"><span>The priority inheritance that was implemented is very rudimentary and is only utilized by the mutexes. &nbsp;The intention was that the priority of the task that acquires the mutex has its priority level stored in the Process Descriptor struct element </span><span class="c0">old_priority. &nbsp;</span><span>This only becomes relevant if other process with higher priority attempt to take hold of the mutex. &nbsp;In </span><span class="c0">kernel_mutex_lock() </span><span>the priority of the current owner of the lock is updated to that of the higher priority task, while the requesting process is appended to a list of tasks waiting for the mutex. &nbsp;This priority change is done through the use of the </span><span class="c0">task_change_priority() </span><span>function by passing it the pid of the current owner of the lock and the priority of the requesting process. &nbsp;</span></p><p class="c1 c2 c4"><span></span></p><p class="c1 c3 c4"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 398.50px; height: 128.04px;"><img alt="" src="images/image09.png" style="width: 398.50px; height: 128.04px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span>&nbsp;</span></p><p class="c1 c3 c4"><span class="c5 c0">Figure 8: task_priority_change Function</span><span>&nbsp;</span></p><p class="c1 c3 c4"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p><h2 class="c1 c6" id="h.e7yyz2gfble"><span>2.4 Mutexes</span></h2><p class="c1 c2"><span></span></p><p class="c1 c2"><span></span></p><p class="c1"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 174.67px;"><img alt="" src="images/image05.png" style="width: 624.00px; height: 174.67px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1 c3"><span class="c5 c0">Figure 9: Mutex State Diagram</span></p><p class="c1 c2"><span></span></p><p class="c1 c2"><span></span></p><p class="c1"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This diagram illustrates what the implementation of the mutexes in the RTOS was meant to follow. &nbsp;The way these states and transitions were translated into code is detailed in the following subsections. &nbsp;When the RTOS is booted, </span><span class="c0">OS_Init() </span><span>initializes an array of structs the size of the maximum number of mutexes allowed by the system. &nbsp;The code for the structs is found in the file </span><span class="c0">kernel.h, </span><span>called </span><span class="c0">MutexLock, </span><span>while the associated enum containing the various mutex states is called </span><span class="c0">mutex_states. &nbsp;</span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1 c3"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 383.50px; height: 220.20px;"><img alt="" src="images/image01.png" style="width: 383.50px; height: 220.20px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1 c3"><span class="c5 c0">Figure 10: Mutex Structs and Enums</span></p><p class="c1 c3 c2"><span class="c5 c0"></span></p><p class="c1 c2"><span></span></p><p class="c1"><span>As can be seen in the in the figure, each mutex has an associated identification of the type MUTEX, a state (i.e. LOCKED), a counter to keep track of how many times the owner of the mutex has locked it, a process descriptor which points to the process that owns the mutex, and a list to keep track of all processes that have requested access to the mutex. &nbsp;</span></p><p class="c1 c2"><span></span></p><h3 class="c1 c6" id="h.6iyzqfb8dfu"><span>2.4.1 Mutex_Init()</span></h3><p class="c1 c2"><span></span></p><p class="c1 c4"><span>The pointer </span><span class="c0">next_lock </span><span>is pointing at the next available spot in the array of mutexes. &nbsp;When a task calls </span><span class="c0">Mutex_Init() </span><span>it takes the MUTEX identifier it was called with and passes it to the free mutex next_lock is pointing to. &nbsp;Then it calls </span><span class="c0">kernel_mutex_init() </span><span>with this mutex id. &nbsp;This kernel function was then meant to check the total number of active mutexes in the system and not exceed the maximum of 8. &nbsp;If the maximum hasn&rsquo;t been reached, the new mutex is initialized with the identifier it was passed as a parameter, the pointer </span><span class="c0">current_lock </span><span>now points to its address, the state of the mutex is UNLOCKED, the counter is set to 0, and the list to keep track of the processes who request to lock the mutex while it is owned by a different process is created. &nbsp;</span><span class="c0">Num_mutexes </span><span>which tracks the total number of mutexes in the system is also incremented.</span></p><p class="c1 c2 c4"><span></span></p><p class="c1 c2 c4"><span></span></p><p class="c1 c3 c4"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 288.00px; height: 130.27px;"><img alt="" src="images/image08.png" style="width: 288.00px; height: 130.27px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1 c3 c4"><span class="c5 c0">Figure 11: Mutex Initialization in Kernel</span></p><p class="c1 c3 c2 c4"><span class="c0"></span></p><h3 class="c1 c6" id="h.f55a8uxakvno"><span>2.4.2 Mutex_Lock(m)</span></h3><p class="c1 c2"><span></span></p><p class="c1"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;When a task calls this function, it does so by passing the identifier,</span><span class="c0">&nbsp;m</span><span>&nbsp;or </span><span class="c0">mid</span><span>, of the mutex it wishes to lock. &nbsp;The pointer current_lock is moved to point at the array spot the mutex associated with that mid is stored. &nbsp;Then the kernel function, </span><span class="c0">kernel_mutex_lock(), </span><span>is called by passing the pointer to the requested mutex and the pointer </span><span class="c0">current_process, </span><span>which points to the process that is making the request. &nbsp;In the kernel, is a series of conditional statements meant to cover all of the possible cases dependent on mutex state and ownership. &nbsp;If the mutex hsa the state UNLOCKED, the pointer </span><span class="c0">owner </span><span>that is in the mutex&rsquo;s struct is changed to point at the requesting process, the mutex state is changed to LOCKED, and </span><span class="c0">lock_count </span><span>is incremented by 1. &nbsp;If the mutex is already locked, but the requesting process is also the owner, then the only action that takes place is that lock_count is incremented. &nbsp;For the situation where the mutex is locked and the owner is a different process, the list </span><span class="c0">requests </span><span>associated with that mutex will append a pointer to the process descriptor to the tail of the list. &nbsp;</span></p><h3 class="c1 c6" id="h.stcbixky4zzw"><span>2.4.3 Mutex_Unlock(m)</span></h3><p class="c1"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p><p class="c1 c4"><span class="c0">Mutex_unlock()</span><span>&nbsp;follows a similar structure to mutex_lock() above. &nbsp;A process passes the identifier, </span><span class="c0">mid, </span><span>of a mutex to this function. &nbsp;The pointer current_lock now points to the mutex and this pointer as well as one to the requesting process is passed to the kernel function, </span><span class="c0">kernel_mutex_unlock(). &nbsp;</span><span>If the requesting process is not the owner of the mutex, the function is aborted and error signal was meant to be sent. &nbsp;If the requesting process is the owner, but it has been locked multiple time, meaning </span><span class="c0">lock_count &nbsp;&gt; 1</span><span>, the only action that takes places is that the counter is decremented by 1. &nbsp;If the count was indeed at 1 and the list of processes waiting for the mutex wasn&rsquo;t empty, the code was meant to take the first task waiting in the list and pass ownership of the mutex to it. &nbsp;Once the new process was the owner, the mutex state would be reset to UNLOCKED, the count would be reset to 0, and kernel_mutex_lock would be called by passing it the new parameters. &nbsp;The last case would be that if lock_count = 1 and there were no processes waiting to acquire it, the state would be returned to UNLOCKED and the count to 0 before exiting the function.</span></p><p class="c1 c2 c4"><span></span></p><h2 class="c1 c6" id="h.msiucuv2hlg6"><span>2.5 Events and Hardware Interrupts</span></h2><h3 class="c1 c3 c6" id="h.s5ztf7xly2nq"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 434.50px; height: 247.86px;"><img alt="" src="images/image12.png" style="width: 434.50px; height: 247.86px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></h3><p class="c1 c3"><span class="c5 c0">Figure 12: Event State Diagram</span></p><p class="c1 c3 c2"><span class="c5 c0"></span></p><p class="c1 c2"><span></span></p><p class="c1"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;While events were not implemented successfully due to time constraints, the above diagram is the basic functionality that was expected. &nbsp;The attempted implementation consisted of adding additional cases to the switch statement in the </span><span class="c0">next_kernel_request() </span><span>function. &nbsp;These cases corresponded to &nbsp;</span><span class="c0">EVENT_SIGNAL, EVENT_WAIT, EVENT_SIGNAL_AND_NEXT. &nbsp;</span></p><p class="c1 c2"><span class="c0"></span></p><h2 class="c1 c6" id="h.2lgp1zy4kb8i"><span>2.6 Errors and Exceptions</span></h2><p class="c1"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p><p class="c1"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;There was an </span><span class="c0">OS_Abort() </span><span>function implemented which is used for unrecoverable errors. &nbsp;It blinks an LED to indicate that the abort took place for the period of a minute. &nbsp;Then a watchdog timer is purposefully expired to soft reset the boar.</span></p><p class="c1 c2"><span class="c16"></span></p><h1 class="c1 c6" id="h.rh0fnha46xpg"><span>3</span><span>. Debugging</span></h1><p class="c1 c2"><span></span></p><p class="c1"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Debugging was done via signalling various LEDs on the Arduino board and using the Logic Analyzer to view the output from the pins. &nbsp;This was done by running tests on various functions and determining when tasks were running or stopping based on the signal captured by the analyzer.</span></p><h1 class="c1 c3 c6" id="h.rczg2welxro2"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 314.50px; height: 266.78px;"><img alt="" src="images/image07.png" style="width: 314.50px; height: 266.78px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></h1><p class="c1 c3"><span class="c5 c0">Figure 13: Debug Function from Common.c</span></p><p class="c1 c3 c2"><span class="c5 c0"></span></p><p class="c1 c3 c2"><span class="c5 c0"></span></p><p class="c1 c3"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 559.50px; height: 419.63px;"><img alt="IMG_20160314_194633.jpg" src="images/image06.jpg" style="width: 559.50px; height: 419.63px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1 c3"><span class="c5 c0">Figure 14: Logic Analyzer Hooked Up to Arduino Mega 2560 Board</span></p><p class="c1 c3 c2"><span class="c5 c0"></span></p><h1 class="c1 c6" id="h.1y2y23ccqcjf"><span>4</span><span>. Testing, Profiling, and Results</span></h1><p class="c1"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p><p class="c1"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Due to the fact that not all functions were successfully implemented, it was difficult to run the provided test cases on the final, albeit incomplete, RTOS. &nbsp;However, the functions that were implemented have been tested and the results from the Logic Analyzer are provided below.</span></p><h1 class="c1 c6" id="h.m62wmgsur1g0"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 332.00px;"><img alt="" src="images/image03.png" style="width: 624.00px; height: 332.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></h1><p class="c1 c3"><span class="c5 c0">Figure 15: Round Robin Task Schedule with 3 Tasks (ping, pong, hard_idle)</span></p><p class="c1 c2"><span></span></p><p class="c1"><span>Even though we didn&rsquo;t get to this step, profiling the kernel is as simple as timing using the logic analyser the duration of the kernel functions by setting a pin high before calling enter kernel and setting the same pin low just before calling exit kernel. </span></p><h1 class="c1 c6" id="h.vafo0lsf06kz"><span>6. Obstacles </span></h1><p class="c1 c2"><span></span></p><p class="c1 c4"><span>The main obstacle/challenge with this project was the lack of feedback in terms of error reporting. Additionally, becoming comfortable with context switching and the code base was difficult. </span></p><p class="c1 c2 c4"><span></span></p><h1 class="c1 c6" id="h.aghije78dvie"><span>7. Code</span></h1><p class="c1"><span>GitHub Repo: </span><span class="c8"><a class="c14" href="https://www.google.com/url?q=https://github.com/breckwagner/CSC460/&amp;sa=D&amp;ust=1459921655668000&amp;usg=AFQjCNGv5USqv30ZUkOT-7FBy41RX22L6A">https://github.com/breckwagner/CSC460/</a></span></p><p class="c1 c2"><span></span></p><p class="c1"><span>Running with defaults:</span></p><p class="c1"><span>$ sudo make program</span></p><p class="c1 c2"><span></span></p><p class="c1"><span>Running with external file with main():</span></p><p class="c1"><span>$ sudo make program MAIN=test*.c</span></p><p class="c1 c2"><span></span></p><p class="c1"><span>Changing COM port</span></p><p class="c1"><span>$ sudo make program AVRDUDE_PORT=/dev/ttyACM</span><span>0</span></p><h1 class="c1 c6 c11" id="h.469pr6ntdmbd"><span></span></h1></body></html>