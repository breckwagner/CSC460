   1               		.file	"shared.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__RAMPZ__ = 0x3b
   6               	__tmp_reg__ = 0
   7               	__zero_reg__ = 1
   8               		.text
   9               	.Ltext0:
  10               		.cfi_sections	.debug_frame
  11               	.global	Ping
  13               	Ping:
  14               	.LFB15:
  15               		.file 1 "shared.c"
   1:shared.c      **** #include <string.h>
   2:shared.c      **** #include <avr/io.h>
   3:shared.c      **** #include <avr/interrupt.h>
   4:shared.c      **** #include <avr/delay.h>
   5:shared.c      **** 
   6:shared.c      **** #define TICKS_PER_SECOND 100ul
   7:shared.c      **** #define ONE_SECOND (TICKS_PER_SECOND)
   8:shared.c      **** #define ONE_MINUTE (60ul * ONE_SECOND)
   9:shared.c      **** #define ONE_HOUR (60ul * ONE_MINUTE)
  10:shared.c      **** 
  11:shared.c      **** volatile unsigned long elapsed = 0;
  12:shared.c      **** 
  13:shared.c      **** 
  14:shared.c      **** /**
  15:shared.c      ****  * \file shared.c
  16:shared.c      ****  * \brief A Skeleton Implementation of an RTOS
  17:shared.c      ****  *
  18:shared.c      ****  * \mainpage A Skeleton Implementation of a "Self-Served" RTOS Model
  19:shared.c      ****  * This is an example of how to implement context-switching based on a
  20:shared.c      ****  * self-served model. That is, the RTOS is implemented by a collection of
  21:shared.c      ****  * user-callable functions. The kernel executes its functions using the calling
  22:shared.c      ****  * task's stack.
  23:shared.c      ****  *
  24:shared.c      ****  * \author Dr. Mantis Cheng
  25:shared.c      ****  * \date 2 October 2006
  26:shared.c      ****  *
  27:shared.c      ****  * ChangeLog: Modified by Alexander M. Hoole, October 2006.
  28:shared.c      ****  *			  -Rectified errors and enabled context switching.
  29:shared.c      ****  *			  -LED Testing code added for development (remove later).
  30:shared.c      ****  *
  31:shared.c      ****  * \section Implementation Note
  32:shared.c      ****  * This example uses the ATMEL AT90USB1287 instruction set as an example
  33:shared.c      ****  * for implementing the context switching mechanism.
  34:shared.c      ****  * This code is ready to be loaded onto an AT90USBKey.  Once loaded the
  35:shared.c      ****  * RTOS scheduling code will alternate lighting of the GREEN LED light on
  36:shared.c      ****  * LED D2 and D5 whenever the correspoing PING and PONG tasks are running.
  37:shared.c      ****  * (See the file "cswitch.S" for details.)
  38:shared.c      ****  */
  39:shared.c      **** 
  40:shared.c      **** //Comment out the following line to remove debugging code from compiled version.
  41:shared.c      **** //#define DEBUG
  42:shared.c      **** 
  43:shared.c      **** typedef void (*voidfuncptr)(void);       /* pointer to void f(void) */
  44:shared.c      **** 
  45:shared.c      **** #define WORKSPACE     256
  46:shared.c      **** #define MAXPROCESS   4
  47:shared.c      **** 
  48:shared.c      **** 
  49:shared.c      **** /*===========
  50:shared.c      ****  * RTOS Internal
  51:shared.c      ****  **===========
  52:shared.c      ****  */
  53:shared.c      **** 
  54:shared.c      **** /**
  55:shared.c      ****  * This internal kernel function is the context switching mechanism.
  56:shared.c      ****  * Fundamentally, the CSwitch() function saves the current task CurrentP's
  57:shared.c      ****  * context, selects a new running task, and then restores the new CurrentP's
  58:shared.c      ****  * context.
  59:shared.c      ****  * (See file "switch.S" for details.)
  60:shared.c      ****  */
  61:shared.c      **** extern void CSwitch();
  62:shared.c      **** 
  63:shared.c      **** /* Prototype */
  64:shared.c      **** void Task_Terminate(void);
  65:shared.c      **** 
  66:shared.c      **** /**
  67:shared.c      ****  * Exit_kernel() is used when OS_Start() or Task_Terminate() needs to
  68:shared.c      ****  * switch to a new running task.
  69:shared.c      ****  */
  70:shared.c      **** extern void Exit_Kernel();
  71:shared.c      **** 
  72:shared.c      **** #define Disable_Interrupt()         asm volatile ("cli" ::)
  73:shared.c      **** #define Enable_Interrupt()          asm volatile ("sei" ::)
  74:shared.c      **** 
  75:shared.c      **** /**
  76:shared.c      ****  *  This is the set of states that a task can be in at any given time.
  77:shared.c      ****  */
  78:shared.c      **** typedef enum process_states
  79:shared.c      **** {
  80:shared.c      ****         DEAD = 0,
  81:shared.c      ****         READY,
  82:shared.c      ****         RUNNING
  83:shared.c      **** } PROCESS_STATES;
  84:shared.c      **** 
  85:shared.c      **** 
  86:shared.c      **** /**
  87:shared.c      ****  * Each task is represented by a process descriptor, which contains all
  88:shared.c      ****  * relevant information about this task. For convenience, we also store
  89:shared.c      ****  * the task's stack, i.e., its workspace, in here.
  90:shared.c      ****  * To simplify our "CSwitch()" assembly code, which needs to access the
  91:shared.c      ****  * "sp" variable during context switching, "sp" MUST BE the first entry
  92:shared.c      ****  * in the ProcessDescriptor.
  93:shared.c      ****  * (See file "cswitch.S" for details.)
  94:shared.c      ****  */
  95:shared.c      **** typedef struct ProcessDescriptor
  96:shared.c      **** {
  97:shared.c      ****         unsigned char *sp;
  98:shared.c      ****         unsigned char workSpace[WORKSPACE];
  99:shared.c      ****         PROCESS_STATES state;
 100:shared.c      **** } PD;
 101:shared.c      **** 
 102:shared.c      **** /**
 103:shared.c      ****  * This table contains ALL process descriptors. It doesn't matter what
 104:shared.c      ****  * state a task is in.
 105:shared.c      ****  */
 106:shared.c      **** static PD Process[MAXPROCESS];
 107:shared.c      **** 
 108:shared.c      **** /**
 109:shared.c      ****  * The process descriptor of the currently RUNNING task.
 110:shared.c      ****  */
 111:shared.c      **** //??? Removed static because it was blocking external access.
 112:shared.c      **** //??? Rename Cp to CurrentP because 'cp' is reserved in assembly.
 113:shared.c      **** volatile PD* CurrentP;
 114:shared.c      **** 
 115:shared.c      **** /** index to next task to run */
 116:shared.c      **** volatile static unsigned int NextP;
 117:shared.c      **** 
 118:shared.c      **** /** 1 if kernel has been started; 0 otherwise. */
 119:shared.c      **** volatile static unsigned int KernelActive;
 120:shared.c      **** 
 121:shared.c      **** /** number of tasks created so far */
 122:shared.c      **** volatile static unsigned int Tasks;
 123:shared.c      **** 
 124:shared.c      **** 
 125:shared.c      **** /**
 126:shared.c      ****  * When creating a new task, it is important to initialize its stack just like
 127:shared.c      ****  * it has called "Enter_Kernel()"; so that when we switch to it later, we
 128:shared.c      ****  * can just restore its execution context on its stack.
 129:shared.c      ****  * (See file "cswitch.S" for details.)
 130:shared.c      ****  */
 131:shared.c      **** void Kernel_Create_Task_At( PD *p, voidfuncptr f )
 132:shared.c      **** {
 133:shared.c      ****         unsigned char *sp;
 134:shared.c      ****         #ifdef DEBUG
 135:shared.c      ****         int counter = 0;
 136:shared.c      ****         #endif
 137:shared.c      **** 
 138:shared.c      ****         sp = (unsigned char *) &(p->workSpace[WORKSPACE-1]);
 139:shared.c      **** 
 140:shared.c      ****         /*----BEGIN of NEW CODE----*/
 141:shared.c      ****         //Initialize the workspace (i.e., stack) and PD here!
 142:shared.c      **** 
 143:shared.c      ****         //Clear the contents of the workspace
 144:shared.c      ****         memset(&(p->workSpace),0,WORKSPACE);
 145:shared.c      **** 
 146:shared.c      ****         //Notice that we are placing the address (16-bit) of the functions
 147:shared.c      ****         //onto the stack in reverse byte order (least significant first, followed
 148:shared.c      ****         //by most significant).  This is because the "return" assembly instructions
 149:shared.c      ****         //(rtn and rti) pop addresses off in BIG ENDIAN (most sig. first, least sig.
 150:shared.c      ****         //second), even though the AT90 is LITTLE ENDIAN machine.
 151:shared.c      **** 
 152:shared.c      ****         //Store terminate at the bottom of stack to protect against stack underrun.
 153:shared.c      ****         *(unsigned char *)sp-- = ((unsigned int)Task_Terminate) & 0xff;
 154:shared.c      ****         *(unsigned char *)sp-- = (((unsigned int)Task_Terminate) >> 8) & 0xff;
 155:shared.c      ****         *(unsigned char *)sp-- = 0;
 156:shared.c      **** 
 157:shared.c      ****         //Place return address of function at bottom of stack
 158:shared.c      ****         *(unsigned char *)sp-- = ((unsigned int)f) & 0xff;
 159:shared.c      ****         *(unsigned char *)sp-- = (((unsigned int)f) >> 8) & 0xff;
 160:shared.c      ****         *(unsigned char *)sp-- = 0;
 161:shared.c      **** 
 162:shared.c      **** #ifdef DEBUG
 163:shared.c      ****         //Fill stack with initial values for development debugging
 164:shared.c      ****         //Registers 0 -> 31 and the status register
 165:shared.c      ****         for (counter = 0; counter < 34; counter++)
 166:shared.c      ****         {
 167:shared.c      ****                 *(unsigned char *)sp-- = counter;
 168:shared.c      ****         }
 169:shared.c      **** #else
 170:shared.c      ****         //Place stack pointer at top of stack
 171:shared.c      ****         sp = sp - 34;
 172:shared.c      **** #endif
 173:shared.c      **** 
 174:shared.c      ****         p->sp = sp; /* stack pointer into the "workSpace" */
 175:shared.c      **** 
 176:shared.c      **** 
 177:shared.c      ****         /*----END of NEW CODE----*/
 178:shared.c      **** 
 179:shared.c      **** 
 180:shared.c      **** 
 181:shared.c      ****         p->state = READY;
 182:shared.c      **** }
 183:shared.c      **** 
 184:shared.c      **** void signal_start_task (uint8_t value) {
 185:shared.c      ****   switch (value) {
 186:shared.c      ****     case 0: PORTL ^= (1<<PL3); PORTL ^= (1<<PL3); break;
 187:shared.c      ****     case 1: PORTL ^= (1<<PL2); PORTL ^= (1<<PL2); break;
 188:shared.c      ****     case 2: PORTL ^= (1<<PL1); PORTL ^= (1<<PL1); break;
 189:shared.c      ****     case 3: PORTL ^= (1<<PL0); PORTL ^= (1<<PL0); break;
 190:shared.c      ****   }
 191:shared.c      **** }
 192:shared.c      **** 
 193:shared.c      **** /**
 194:shared.c      ****  *  Create a new task
 195:shared.c      ****  */
 196:shared.c      **** static void Kernel_Create_Task( voidfuncptr f )
 197:shared.c      **** {
 198:shared.c      ****         int x;
 199:shared.c      **** 
 200:shared.c      ****         if (Tasks == MAXPROCESS) return;  /* Too many task! */
 201:shared.c      **** 
 202:shared.c      ****         /* find a DEAD PD that we can use  */
 203:shared.c      ****         for (x = 0; x < MAXPROCESS; x++) {
 204:shared.c      ****                 if (Process[x].state == DEAD) break;
 205:shared.c      ****         }
 206:shared.c      **** 
 207:shared.c      ****         ++Tasks;
 208:shared.c      ****         Kernel_Create_Task_At( &(Process[x]), f );
 209:shared.c      **** }
 210:shared.c      **** 
 211:shared.c      **** /**
 212:shared.c      ****  * This internal kernel function is a part of the "scheduler". It chooses the
 213:shared.c      ****  * next task to run, i.e., CurrentP.
 214:shared.c      ****  */
 215:shared.c      **** //Remobed static because it was blocking external access from assembly file cswitch.S.
 216:shared.c      **** //We desire to see a 'T' not a 't' in the avr-nm output from the object file.
 217:shared.c      **** void Dispatch()
 218:shared.c      **** {
 219:shared.c      ****         /* find the next READY task
 220:shared.c      ****          * Note: if there is no READY task, then this will loop forever!.
 221:shared.c      ****          */
 222:shared.c      ****         while(Process[NextP].state != READY) {
 223:shared.c      ****                 NextP = (NextP + 1) % MAXPROCESS;
 224:shared.c      ****         }
 225:shared.c      **** 
 226:shared.c      ****         signal_start_task(NextP);
 227:shared.c      **** 
 228:shared.c      ****         /* we have a new CurrentP */
 229:shared.c      ****         CurrentP = &(Process[NextP]);
 230:shared.c      ****         CurrentP->state = RUNNING;
 231:shared.c      **** 
 232:shared.c      ****         //Moved to bottom (this was in the wrong place).
 233:shared.c      ****         NextP = (NextP + 1) % MAXPROCESS;
 234:shared.c      **** }
 235:shared.c      **** 
 236:shared.c      **** 
 237:shared.c      **** /*================
 238:shared.c      ****  * RTOS  API  and Stubs
 239:shared.c      ****  **================
 240:shared.c      ****  */
 241:shared.c      **** 
 242:shared.c      **** /**
 243:shared.c      ****  * This function initializes the RTOS and must be called before any other
 244:shared.c      ****  * system calls.
 245:shared.c      ****  */
 246:shared.c      **** void OS_Init()
 247:shared.c      **** {
 248:shared.c      ****         int x;
 249:shared.c      **** 
 250:shared.c      ****         Tasks = 0;
 251:shared.c      ****         KernelActive = 0;
 252:shared.c      ****         NextP = 0;
 253:shared.c      **** 
 254:shared.c      ****         for (x = 0; x < MAXPROCESS; x++) {
 255:shared.c      ****                 memset(&(Process[x]),0,sizeof(PD));
 256:shared.c      ****                 Process[x].state = DEAD;
 257:shared.c      ****         }
 258:shared.c      **** }
 259:shared.c      **** 
 260:shared.c      **** 
 261:shared.c      **** /**
 262:shared.c      ****  * This function starts the RTOS after creating a few tasks.
 263:shared.c      ****  */
 264:shared.c      **** void OS_Start()
 265:shared.c      **** {
 266:shared.c      ****         if ( (!KernelActive) && (Tasks > 0)) {
 267:shared.c      ****                 Disable_Interrupt();
 268:shared.c      **** 
 269:shared.c      ****                 /* here we go...  */
 270:shared.c      ****                 KernelActive = 1;
 271:shared.c      ****                 asm ( "jmp Exit_Kernel" :: );
 272:shared.c      ****         }
 273:shared.c      **** }
 274:shared.c      **** 
 275:shared.c      **** 
 276:shared.c      **** /**
 277:shared.c      ****  * For this example, we only support cooperatively multitasking, i.e.,
 278:shared.c      ****  * each task gives up its share of the processor voluntarily by calling
 279:shared.c      ****  * Task_Next().
 280:shared.c      ****  */
 281:shared.c      **** void Task_Create( voidfuncptr f) {
 282:shared.c      ****   Disable_Interrupt();
 283:shared.c      ****   Kernel_Create_Task( f );
 284:shared.c      ****   Enable_Interrupt();
 285:shared.c      **** }
 286:shared.c      **** 
 287:shared.c      **** /**
 288:shared.c      ****  * The calling task gives up its share of the processor voluntarily.
 289:shared.c      ****  */
 290:shared.c      **** void Task_Next()
 291:shared.c      **** {
 292:shared.c      ****         if (KernelActive) {
 293:shared.c      ****                 Disable_Interrupt();
 294:shared.c      ****                 CurrentP->state = READY;
 295:shared.c      **** 
 296:shared.c      ****                 CSwitch();
 297:shared.c      ****                 /* resume here when this task is rescheduled again later */
 298:shared.c      ****                 Enable_Interrupt();
 299:shared.c      ****         }
 300:shared.c      **** }
 301:shared.c      **** 
 302:shared.c      **** 
 303:shared.c      **** /**
 304:shared.c      ****  * The calling task terminates itself.
 305:shared.c      ****  */
 306:shared.c      **** void Task_Terminate()
 307:shared.c      **** {
 308:shared.c      ****         if (KernelActive) {
 309:shared.c      ****                 Disable_Interrupt();
 310:shared.c      ****                 CurrentP->state = DEAD;
 311:shared.c      ****                 /* we will NEVER return here! */
 312:shared.c      ****                 asm ( "jmp Exit_Kernel" :: );
 313:shared.c      ****         }
 314:shared.c      **** }
 315:shared.c      **** 
 316:shared.c      **** void Ping() {
  16               		.loc 1 316 0
  17               		.cfi_startproc
  18               	/* prologue: function */
  19               	/* frame size = 0 */
  20               	/* stack size = 0 */
  21               	.L__stack_usage = 0
  22               	.L3:
 317:shared.c      ****         int x;
 318:shared.c      ****         //DDRB = (1<<PB6); // INIT PIN 12
 319:shared.c      ****         for(;;) {
 320:shared.c      ****                 PORTB |= (1<<PB7);
  23               		.loc 1 320 0
  24 0000 2F9A      		sbi 0x5,7
  25               	.LVL0:
  26 0002 80E0      		ldi r24,0
  27 0004 9DE7      		ldi r25,lo8(125)
  28               	.LVL1:
  29               	.L4:
  30 0006 0197      		sbiw r24,1
  31               	.LVL2:
 321:shared.c      **** 
 322:shared.c      ****                 //PORTC |= (1<<PINC7);
 323:shared.c      ****                 //_delay_ms(1000);
 324:shared.c      ****                 for( x=0; x < 32000; ++x ) ;  // do nothing
  32               		.loc 1 324 0 discriminator 2
  33 0008 0097      		sbiw r24,0
  34 000a 01F4      		brne .L4
  35 000c 00C0      		rjmp .L3
  36               		.cfi_endproc
  37               	.LFE15:
  39               	.global	Pong
  41               	Pong:
  42               	.LFB16:
 325:shared.c      ****                 for( x=0; x < 32000; ++x ) ;  // do nothing
 326:shared.c      ****                 for( x=0; x < 32000; ++x ) ;  // do nothing
 327:shared.c      **** 
 328:shared.c      **** 
 329:shared.c      ****                 //LED off
 330:shared.c      ****                 //PORTB &= ~(1<<PB6);
 331:shared.c      **** 
 332:shared.c      ****                 // printf( "*" );
 333:shared.c      ****                 //Task_Next();
 334:shared.c      ****         }
 335:shared.c      **** }
 336:shared.c      **** 
 337:shared.c      **** 
 338:shared.c      **** /**
 339:shared.c      ****  * A cooperative "Pong" task.
 340:shared.c      ****  * Added testing code for LEDs.
 341:shared.c      ****  */
 342:shared.c      **** void Pong()
 343:shared.c      **** {
  43               		.loc 1 343 0
  44               		.cfi_startproc
  45               	/* prologue: function */
  46               	/* frame size = 0 */
  47               	/* stack size = 0 */
  48               	.L__stack_usage = 0
  49               	.L8:
 344:shared.c      ****         int x;
 345:shared.c      **** 
 346:shared.c      ****         for(;;) {
 347:shared.c      **** 
 348:shared.c      ****                 PORTB &= ~(1<<PB7);
  50               		.loc 1 348 0
  51 000e 2F98      		cbi 0x5,7
  52               	.LVL3:
  53 0010 80E0      		ldi r24,0
  54 0012 9DE7      		ldi r25,lo8(125)
  55               	.LVL4:
  56               	.L9:
  57 0014 0197      		sbiw r24,1
  58               	.LVL5:
 349:shared.c      ****                 //PORTC |= (1<<PINC7);
 350:shared.c      ****                 //PORTC &= ~(1<<PINC7);
 351:shared.c      ****                 //_delay_ms(1000);
 352:shared.c      ****                 for( x=0; x < 32000; ++x ) ;  /* do nothing */
  59               		.loc 1 352 0 discriminator 2
  60 0016 0097      		sbiw r24,0
  61 0018 01F4      		brne .L9
  62 001a 00C0      		rjmp .L8
  63               		.cfi_endproc
  64               	.LFE16:
  66               	.global	Task_Terminate
  68               	Task_Terminate:
  69               	.LFB14:
 307:shared.c      ****         if (KernelActive) {
  70               		.loc 1 307 0
  71               		.cfi_startproc
  72               	/* prologue: function */
  73               	/* frame size = 0 */
  74               	/* stack size = 0 */
  75               	.L__stack_usage = 0
 308:shared.c      ****                 Disable_Interrupt();
  76               		.loc 1 308 0
  77 001c 8091 0000 		lds r24,KernelActive
  78 0020 9091 0000 		lds r25,KernelActive+1
  79 0024 892B      		or r24,r25
  80 0026 01F0      		breq .L10
  81               	.LBB10:
  82               	.LBB11:
 309:shared.c      ****                 CurrentP->state = DEAD;
  83               		.loc 1 309 0
  84               	/* #APP */
  85               	 ;  309 "shared.c" 1
  86 0028 F894      		cli
  87               	 ;  0 "" 2
 310:shared.c      ****                 /* we will NEVER return here! */
  88               		.loc 1 310 0
  89               	/* #NOAPP */
  90 002a E091 0000 		lds r30,CurrentP
  91 002e F091 0000 		lds r31,CurrentP+1
  92 0032 EE5F      		subi r30,-2
  93 0034 FE4F      		sbci r31,-2
  94 0036 1082      		st Z,__zero_reg__
 312:shared.c      ****         }
  95               		.loc 1 312 0
  96               	/* #APP */
  97               	 ;  312 "shared.c" 1
  98 0038 0C94 0000 		jmp Exit_Kernel
  99               	 ;  0 "" 2
 100               	/* #NOAPP */
 101               	.L10:
 102 003c 0895      		ret
 103               	.LBE11:
 104               	.LBE10:
 105               		.cfi_endproc
 106               	.LFE14:
 108               	.global	Kernel_Create_Task_At
 110               	Kernel_Create_Task_At:
 111               	.LFB6:
 132:shared.c      ****         unsigned char *sp;
 112               		.loc 1 132 0
 113               		.cfi_startproc
 114               	.LVL6:
 115               	/* prologue: function */
 116               	/* frame size = 0 */
 117               	/* stack size = 0 */
 118               	.L__stack_usage = 0
 144:shared.c      **** 
 119               		.loc 1 144 0
 120 003e FC01      		movw r30,r24
 121 0040 3296      		adiw r30,2
 122 0042 20E0      		ldi r18,0
 123 0044 31E0      		ldi r19,lo8(1)
 124 0046 DF01      		movw r26,r30
 125 0048 A901      		movw r20,r18
 126               		0:
 127 004a 1D92      		st X+,__zero_reg__
 128 004c 4150      		subi r20,1
 129 004e 5040      		sbci r21,0
 130 0050 01F4      		brne 0b
 131               	.LVL7:
 153:shared.c      ****         *(unsigned char *)sp-- = (((unsigned int)Task_Terminate) >> 8) & 0xff;
 132               		.loc 1 153 0
 133 0052 E150      		subi r30,1
 134 0054 FF4F      		sbci r31,-1
 135 0056 20E0      		ldi r18,lo8(gs(Task_Terminate))
 136 0058 30E0      		ldi r19,hi8(gs(Task_Terminate))
 137 005a 2083      		st Z,r18
 138               	.LVL8:
 154:shared.c      ****         *(unsigned char *)sp-- = 0;
 139               		.loc 1 154 0
 140 005c 3197      		sbiw r30,1
 141 005e 3083      		st Z,r19
 142               	.LVL9:
 155:shared.c      **** 
 143               		.loc 1 155 0
 144 0060 3197      		sbiw r30,1
 145 0062 1082      		st Z,__zero_reg__
 146               	.LVL10:
 158:shared.c      ****         *(unsigned char *)sp-- = (((unsigned int)f) >> 8) & 0xff;
 147               		.loc 1 158 0
 148 0064 3197      		sbiw r30,1
 149 0066 6083      		st Z,r22
 150               	.LVL11:
 159:shared.c      ****         *(unsigned char *)sp-- = 0;
 151               		.loc 1 159 0
 152 0068 3197      		sbiw r30,1
 153 006a 7083      		st Z,r23
 154               	.LVL12:
 160:shared.c      **** 
 155               		.loc 1 160 0
 156 006c 3197      		sbiw r30,1
 157 006e 1082      		st Z,__zero_reg__
 158               	.LVL13:
 171:shared.c      **** #endif
 159               		.loc 1 171 0
 160 0070 9C01      		movw r18,r24
 161 0072 2752      		subi r18,39
 162 0074 3F4F      		sbci r19,-1
 163               	.LVL14:
 174:shared.c      **** 
 164               		.loc 1 174 0
 165 0076 DC01      		movw r26,r24
 166 0078 2D93      		st X+,r18
 167 007a 3C93      		st X,r19
 181:shared.c      **** }
 168               		.loc 1 181 0
 169 007c 3696      		adiw r30,6
 170 007e 21E0      		ldi r18,lo8(1)
 171               	.LVL15:
 172 0080 2083      		st Z,r18
 173 0082 0895      		ret
 174               		.cfi_endproc
 175               	.LFE6:
 178               	Kernel_Create_Task:
 179               	.LFB8:
 197:shared.c      ****         int x;
 180               		.loc 1 197 0
 181               		.cfi_startproc
 182               	.LVL16:
 183               	/* prologue: function */
 184               	/* frame size = 0 */
 185               	/* stack size = 0 */
 186               	.L__stack_usage = 0
 200:shared.c      **** 
 187               		.loc 1 200 0
 188 0084 2091 0000 		lds r18,Tasks
 189 0088 3091 0000 		lds r19,Tasks+1
 190 008c 2430      		cpi r18,4
 191 008e 3105      		cpc r19,__zero_reg__
 192 0090 01F0      		breq .L16
 193 0092 E0E0      		ldi r30,lo8(Process+258)
 194 0094 F0E0      		ldi r31,hi8(Process+258)
 195 0096 20E0      		ldi r18,0
 196 0098 30E0      		ldi r19,0
 197               	.L19:
 198               	.LVL17:
 204:shared.c      ****         }
 199               		.loc 1 204 0
 200 009a 4081      		ld r20,Z
 201 009c 4423      		tst r20
 202 009e 01F0      		breq .L18
 203:shared.c      ****                 if (Process[x].state == DEAD) break;
 203               		.loc 1 203 0
 204 00a0 2F5F      		subi r18,-1
 205 00a2 3F4F      		sbci r19,-1
 206               	.LVL18:
 207 00a4 ED5F      		subi r30,-3
 208 00a6 FE4F      		sbci r31,-2
 209 00a8 2430      		cpi r18,4
 210 00aa 3105      		cpc r19,__zero_reg__
 211 00ac 01F4      		brne .L19
 212               	.L18:
 207:shared.c      ****         Kernel_Create_Task_At( &(Process[x]), f );
 213               		.loc 1 207 0
 214 00ae 4091 0000 		lds r20,Tasks
 215 00b2 5091 0000 		lds r21,Tasks+1
 216 00b6 4F5F      		subi r20,-1
 217 00b8 5F4F      		sbci r21,-1
 218 00ba 5093 0000 		sts Tasks+1,r21
 219 00be 4093 0000 		sts Tasks,r20
 208:shared.c      **** }
 220               		.loc 1 208 0
 221 00c2 A901      		movw r20,r18
 222 00c4 440F      		lsl r20
 223 00c6 551F      		rol r21
 224 00c8 722F      		mov r23,r18
 225 00ca 6627      		clr r22
 226 00cc 460F      		add r20,r22
 227 00ce 571F      		adc r21,r23
 228 00d0 420F      		add r20,r18
 229 00d2 531F      		adc r21,r19
 230 00d4 BC01      		movw r22,r24
 231 00d6 CA01      		movw r24,r20
 232               	.LVL19:
 233 00d8 8050      		subi r24,lo8(-(Process))
 234 00da 9040      		sbci r25,hi8(-(Process))
 235 00dc 0C94 0000 		jmp Kernel_Create_Task_At
 236               	.LVL20:
 237               	.L16:
 238 00e0 0895      		ret
 239               		.cfi_endproc
 240               	.LFE8:
 242               	.global	signal_start_task
 244               	signal_start_task:
 245               	.LFB7:
 184:shared.c      ****   switch (value) {
 246               		.loc 1 184 0
 247               		.cfi_startproc
 248               	.LVL21:
 249               	/* prologue: function */
 250               	/* frame size = 0 */
 251               	/* stack size = 0 */
 252               	.L__stack_usage = 0
 185:shared.c      ****     case 0: PORTL ^= (1<<PL3); PORTL ^= (1<<PL3); break;
 253               		.loc 1 185 0
 254 00e2 8130      		cpi r24,lo8(1)
 255 00e4 01F0      		breq .L28
 256 00e6 00F0      		brlo .L29
 257 00e8 8230      		cpi r24,lo8(2)
 258 00ea 01F0      		breq .L30
 259 00ec 8330      		cpi r24,lo8(3)
 260 00ee 01F0      		breq .L31
 261 00f0 0895      		ret
 262               	.L30:
 188:shared.c      ****     case 3: PORTL ^= (1<<PL0); PORTL ^= (1<<PL0); break;
 263               		.loc 1 188 0
 264 00f2 9091 0B01 		lds r25,267
 265 00f6 9827      		eor r25,r24
 266 00f8 9093 0B01 		sts 267,r25
 267 00fc 9091 0B01 		lds r25,267
 268 0100 9827      		eor r25,r24
 269 0102 9093 0B01 		sts 267,r25
 270 0106 0895      		ret
 271               	.L31:
 189:shared.c      ****   }
 272               		.loc 1 189 0
 273 0108 8091 0B01 		lds r24,267
 274               	.LVL22:
 275 010c 91E0      		ldi r25,lo8(1)
 276               	.L32:
 277 010e 8927      		eor r24,r25
 278 0110 8093 0B01 		sts 267,r24
 279 0114 8091 0B01 		lds r24,267
 280 0118 8927      		eor r24,r25
 281 011a 8093 0B01 		sts 267,r24
 282 011e 0895      		ret
 283               	.LVL23:
 284               	.L29:
 186:shared.c      ****     case 1: PORTL ^= (1<<PL2); PORTL ^= (1<<PL2); break;
 285               		.loc 1 186 0
 286 0120 8091 0B01 		lds r24,267
 287               	.LVL24:
 288 0124 98E0      		ldi r25,lo8(8)
 289 0126 00C0      		rjmp .L32
 290               	.LVL25:
 291               	.L28:
 187:shared.c      ****     case 2: PORTL ^= (1<<PL1); PORTL ^= (1<<PL1); break;
 292               		.loc 1 187 0
 293 0128 8091 0B01 		lds r24,267
 294               	.LVL26:
 295 012c 94E0      		ldi r25,lo8(4)
 296 012e 00C0      		rjmp .L32
 297               		.cfi_endproc
 298               	.LFE7:
 300               	.global	Dispatch
 302               	Dispatch:
 303               	.LFB9:
 218:shared.c      ****         /* find the next READY task
 304               		.loc 1 218 0
 305               		.cfi_startproc
 306               	.L43:
 307               	/* prologue: function */
 308               	/* frame size = 0 */
 309               	/* stack size = 0 */
 310               	.L__stack_usage = 0
 222:shared.c      ****                 NextP = (NextP + 1) % MAXPROCESS;
 311               		.loc 1 222 0
 312 0130 8091 0000 		lds r24,NextP
 313 0134 9091 0000 		lds r25,NextP+1
 314 0138 FC01      		movw r30,r24
 315 013a EE0F      		lsl r30
 316 013c FF1F      		rol r31
 317 013e 382F      		mov r19,r24
 318 0140 2227      		clr r18
 319 0142 E20F      		add r30,r18
 320 0144 F31F      		adc r31,r19
 321 0146 E80F      		add r30,r24
 322 0148 F91F      		adc r31,r25
 323 014a E050      		subi r30,lo8(-(Process+258))
 324 014c F040      		sbci r31,hi8(-(Process+258))
 325 014e 8081      		ld r24,Z
 326 0150 8130      		cpi r24,lo8(1)
 327 0152 01F0      		breq .L44
 223:shared.c      ****         }
 328               		.loc 1 223 0
 329 0154 8091 0000 		lds r24,NextP
 330 0158 9091 0000 		lds r25,NextP+1
 331 015c 0196      		adiw r24,1
 332 015e 8370      		andi r24,3
 333 0160 9927      		clr r25
 334 0162 9093 0000 		sts NextP+1,r25
 335 0166 8093 0000 		sts NextP,r24
 336 016a 00C0      		rjmp .L43
 337               	.L44:
 226:shared.c      **** 
 338               		.loc 1 226 0
 339 016c 8091 0000 		lds r24,NextP
 340 0170 9091 0000 		lds r25,NextP+1
 341 0174 0E94 0000 		call signal_start_task
 342               	.LVL27:
 229:shared.c      ****         CurrentP->state = RUNNING;
 343               		.loc 1 229 0
 344 0178 2091 0000 		lds r18,NextP
 345 017c 3091 0000 		lds r19,NextP+1
 346 0180 C901      		movw r24,r18
 347 0182 880F      		lsl r24
 348 0184 991F      		rol r25
 349 0186 522F      		mov r21,r18
 350 0188 4427      		clr r20
 351 018a 840F      		add r24,r20
 352 018c 951F      		adc r25,r21
 353 018e 820F      		add r24,r18
 354 0190 931F      		adc r25,r19
 355 0192 8050      		subi r24,lo8(-(Process))
 356 0194 9040      		sbci r25,hi8(-(Process))
 357 0196 9093 0000 		sts CurrentP+1,r25
 358 019a 8093 0000 		sts CurrentP,r24
 230:shared.c      **** 
 359               		.loc 1 230 0
 360 019e FC01      		movw r30,r24
 361 01a0 EE5F      		subi r30,-2
 362 01a2 FE4F      		sbci r31,-2
 363 01a4 22E0      		ldi r18,lo8(2)
 364 01a6 2083      		st Z,r18
 233:shared.c      **** }
 365               		.loc 1 233 0
 366 01a8 8091 0000 		lds r24,NextP
 367 01ac 9091 0000 		lds r25,NextP+1
 368 01b0 0196      		adiw r24,1
 369 01b2 8370      		andi r24,3
 370 01b4 9927      		clr r25
 371 01b6 9093 0000 		sts NextP+1,r25
 372 01ba 8093 0000 		sts NextP,r24
 373 01be 0895      		ret
 374               		.cfi_endproc
 375               	.LFE9:
 377               	.global	OS_Init
 379               	OS_Init:
 380               	.LFB10:
 247:shared.c      ****         int x;
 381               		.loc 1 247 0
 382               		.cfi_startproc
 383               	/* prologue: function */
 384               	/* frame size = 0 */
 385               	/* stack size = 0 */
 386               	.L__stack_usage = 0
 250:shared.c      ****         KernelActive = 0;
 387               		.loc 1 250 0
 388 01c0 1092 0000 		sts Tasks+1,__zero_reg__
 389 01c4 1092 0000 		sts Tasks,__zero_reg__
 251:shared.c      ****         NextP = 0;
 390               		.loc 1 251 0
 391 01c8 1092 0000 		sts KernelActive+1,__zero_reg__
 392 01cc 1092 0000 		sts KernelActive,__zero_reg__
 252:shared.c      **** 
 393               		.loc 1 252 0
 394 01d0 1092 0000 		sts NextP+1,__zero_reg__
 395 01d4 1092 0000 		sts NextP,__zero_reg__
 396               	.LVL28:
 397 01d8 E0E0      		ldi r30,lo8(Process)
 398 01da F0E0      		ldi r31,hi8(Process)
 255:shared.c      ****                 Process[x].state = DEAD;
 399               		.loc 1 255 0
 400 01dc 83E0      		ldi r24,lo8(3)
 401 01de 91E0      		ldi r25,lo8(1)
 402               	.LVL29:
 403               	.L47:
 255:shared.c      ****                 Process[x].state = DEAD;
 404               		.loc 1 255 0 is_stmt 0 discriminator 2
 405 01e0 DF01      		movw r26,r30
 406 01e2 9C01      		movw r18,r24
 407               		0:
 408 01e4 1D92      		st X+,__zero_reg__
 409 01e6 2150      		subi r18,1
 410 01e8 3040      		sbci r19,0
 411 01ea 01F4      		brne 0b
 412 01ec DF01      		movw r26,r30
 413 01ee AE5F      		subi r26,-2
 414 01f0 BE4F      		sbci r27,-2
 256:shared.c      ****         }
 415               		.loc 1 256 0 is_stmt 1 discriminator 2
 416 01f2 1C92      		st X,__zero_reg__
 417 01f4 ED5F      		subi r30,-3
 418 01f6 FE4F      		sbci r31,-2
 254:shared.c      ****                 memset(&(Process[x]),0,sizeof(PD));
 419               		.loc 1 254 0 discriminator 2
 420 01f8 30E0      		ldi r19,hi8(Process+1036)
 421 01fa E030      		cpi r30,lo8(Process+1036)
 422 01fc F307      		cpc r31,r19
 423 01fe 01F4      		brne .L47
 424               	/* epilogue start */
 258:shared.c      **** 
 425               		.loc 1 258 0
 426 0200 0895      		ret
 427               		.cfi_endproc
 428               	.LFE10:
 430               	.global	OS_Start
 432               	OS_Start:
 433               	.LFB11:
 265:shared.c      ****         if ( (!KernelActive) && (Tasks > 0)) {
 434               		.loc 1 265 0
 435               		.cfi_startproc
 436               	/* prologue: function */
 437               	/* frame size = 0 */
 438               	/* stack size = 0 */
 439               	.L__stack_usage = 0
 266:shared.c      ****                 Disable_Interrupt();
 440               		.loc 1 266 0
 441 0202 8091 0000 		lds r24,KernelActive
 442 0206 9091 0000 		lds r25,KernelActive+1
 443 020a 892B      		or r24,r25
 444 020c 01F4      		brne .L48
 266:shared.c      ****                 Disable_Interrupt();
 445               		.loc 1 266 0 is_stmt 0 discriminator 1
 446 020e 8091 0000 		lds r24,Tasks
 447 0212 9091 0000 		lds r25,Tasks+1
 448 0216 892B      		or r24,r25
 449 0218 01F0      		breq .L48
 267:shared.c      **** 
 450               		.loc 1 267 0 is_stmt 1
 451               	/* #APP */
 452               	 ;  267 "shared.c" 1
 453 021a F894      		cli
 454               	 ;  0 "" 2
 270:shared.c      ****                 asm ( "jmp Exit_Kernel" :: );
 455               		.loc 1 270 0
 456               	/* #NOAPP */
 457 021c 81E0      		ldi r24,lo8(1)
 458 021e 90E0      		ldi r25,0
 459 0220 9093 0000 		sts KernelActive+1,r25
 460 0224 8093 0000 		sts KernelActive,r24
 271:shared.c      ****         }
 461               		.loc 1 271 0
 462               	/* #APP */
 463               	 ;  271 "shared.c" 1
 464 0228 0C94 0000 		jmp Exit_Kernel
 465               	 ;  0 "" 2
 466               	/* #NOAPP */
 467               	.L48:
 468 022c 0895      		ret
 469               		.cfi_endproc
 470               	.LFE11:
 472               	.global	Task_Create
 474               	Task_Create:
 475               	.LFB12:
 281:shared.c      ****   Disable_Interrupt();
 476               		.loc 1 281 0
 477               		.cfi_startproc
 478               	.LVL30:
 479               	/* prologue: function */
 480               	/* frame size = 0 */
 481               	/* stack size = 0 */
 482               	.L__stack_usage = 0
 282:shared.c      ****   Kernel_Create_Task( f );
 483               		.loc 1 282 0
 484               	/* #APP */
 485               	 ;  282 "shared.c" 1
 486 022e F894      		cli
 487               	 ;  0 "" 2
 283:shared.c      ****   Enable_Interrupt();
 488               		.loc 1 283 0
 489               	/* #NOAPP */
 490 0230 0E94 0000 		call Kernel_Create_Task
 491               	.LVL31:
 284:shared.c      **** }
 492               		.loc 1 284 0
 493               	/* #APP */
 494               	 ;  284 "shared.c" 1
 495 0234 7894      		sei
 496               	 ;  0 "" 2
 497               	/* #NOAPP */
 498 0236 0895      		ret
 499               		.cfi_endproc
 500               	.LFE12:
 502               	.global	Task_Next
 504               	Task_Next:
 505               	.LFB13:
 291:shared.c      ****         if (KernelActive) {
 506               		.loc 1 291 0
 507               		.cfi_startproc
 508               	/* prologue: function */
 509               	/* frame size = 0 */
 510               	/* stack size = 0 */
 511               	.L__stack_usage = 0
 292:shared.c      ****                 Disable_Interrupt();
 512               		.loc 1 292 0
 513 0238 8091 0000 		lds r24,KernelActive
 514 023c 9091 0000 		lds r25,KernelActive+1
 515 0240 892B      		or r24,r25
 516 0242 01F4      		brne .L59
 517 0244 0895      		ret
 518               	.L59:
 293:shared.c      ****                 CurrentP->state = READY;
 519               		.loc 1 293 0
 520               	/* #APP */
 521               	 ;  293 "shared.c" 1
 522 0246 F894      		cli
 523               	 ;  0 "" 2
 294:shared.c      **** 
 524               		.loc 1 294 0
 525               	/* #NOAPP */
 526 0248 E091 0000 		lds r30,CurrentP
 527 024c F091 0000 		lds r31,CurrentP+1
 528 0250 EE5F      		subi r30,-2
 529 0252 FE4F      		sbci r31,-2
 530 0254 81E0      		ldi r24,lo8(1)
 531 0256 8083      		st Z,r24
 296:shared.c      ****                 /* resume here when this task is rescheduled again later */
 532               		.loc 1 296 0
 533 0258 0E94 0000 		call CSwitch
 534               	.LVL32:
 298:shared.c      ****         }
 535               		.loc 1 298 0
 536               	/* #APP */
 537               	 ;  298 "shared.c" 1
 538 025c 7894      		sei
 539               	 ;  0 "" 2
 540               	/* #NOAPP */
 541 025e 0895      		ret
 542               		.cfi_endproc
 543               	.LFE13:
 545               	.global	init_timer
 547               	init_timer:
 548               	.LFB17:
 353:shared.c      ****                 for( x=0; x < 32000; ++x ) ;  /* do nothing */
 354:shared.c      ****                 for( x=0; x < 32000; ++x ) ;  /* do nothing */
 355:shared.c      **** 
 356:shared.c      ****                 //LED off
 357:shared.c      **** 
 358:shared.c      **** 
 359:shared.c      ****                 /* printf( "." );  */
 360:shared.c      ****                 //Task_Next();
 361:shared.c      **** 
 362:shared.c      ****         }
 363:shared.c      **** }
 364:shared.c      **** 
 365:shared.c      **** 
 366:shared.c      **** void init_timer () {
 549               		.loc 1 366 0
 550               		.cfi_startproc
 551               	/* prologue: function */
 552               	/* frame size = 0 */
 553               	/* stack size = 0 */
 554               	.L__stack_usage = 0
 367:shared.c      ****   // initialize Timer1
 368:shared.c      ****   Disable_Interrupt();          // disable global interrupts
 555               		.loc 1 368 0
 556               	/* #APP */
 557               	 ;  368 "shared.c" 1
 558 0260 F894      		cli
 559               	 ;  0 "" 2
 369:shared.c      ****   TCCR1A = 0;     // set entire TCCR1A register to 0
 560               		.loc 1 369 0
 561               	/* #NOAPP */
 562 0262 1092 8000 		sts 128,__zero_reg__
 370:shared.c      ****   TCCR1B = 0;     // same for TCCR1B
 563               		.loc 1 370 0
 564 0266 E1E8      		ldi r30,lo8(-127)
 565 0268 F0E0      		ldi r31,0
 566 026a 1082      		st Z,__zero_reg__
 371:shared.c      **** 
 372:shared.c      ****   // set compare match register to desired timer count:
 373:shared.c      ****   OCR1A = 15624;
 567               		.loc 1 373 0
 568 026c 88E0      		ldi r24,lo8(8)
 569 026e 9DE3      		ldi r25,lo8(61)
 570 0270 9093 8900 		sts 136+1,r25
 571 0274 8093 8800 		sts 136,r24
 374:shared.c      **** 
 375:shared.c      ****   // turn on CTC mode:
 376:shared.c      ****   TCCR1B |= (1 << WGM12);
 572               		.loc 1 376 0
 573 0278 8081      		ld r24,Z
 574 027a 8860      		ori r24,lo8(8)
 575 027c 8083      		st Z,r24
 377:shared.c      **** 
 378:shared.c      ****   // Set CS10 and CS12 bits for 1024 prescaler:
 379:shared.c      ****   TCCR1B |= (1 << CS10);
 576               		.loc 1 379 0
 577 027e 8081      		ld r24,Z
 578 0280 8160      		ori r24,lo8(1)
 579 0282 8083      		st Z,r24
 380:shared.c      ****   TCCR1B |= (1 << CS12);
 580               		.loc 1 380 0
 581 0284 8081      		ld r24,Z
 582 0286 8460      		ori r24,lo8(4)
 583 0288 8083      		st Z,r24
 381:shared.c      **** 
 382:shared.c      ****   // enable timer compare interrupt:
 383:shared.c      ****   TIMSK1 |= (1 << OCIE1A);
 584               		.loc 1 383 0
 585 028a EFE6      		ldi r30,lo8(111)
 586 028c F0E0      		ldi r31,0
 587 028e 8081      		ld r24,Z
 588 0290 8260      		ori r24,lo8(2)
 589 0292 8083      		st Z,r24
 384:shared.c      **** 
 385:shared.c      ****   // enable global interrupts:
 386:shared.c      ****   Enable_Interrupt();
 590               		.loc 1 386 0
 591               	/* #APP */
 592               	 ;  386 "shared.c" 1
 593 0294 7894      		sei
 594               	 ;  0 "" 2
 595               	/* #NOAPP */
 596 0296 0895      		ret
 597               		.cfi_endproc
 598               	.LFE17:
 600               		.section	.text.startup,"ax",@progbits
 601               	.global	main
 603               	main:
 604               	.LFB18:
 387:shared.c      **** }
 388:shared.c      **** 
 389:shared.c      **** 
 390:shared.c      **** /**
 391:shared.c      ****  * This function creates two cooperative tasks, "Ping" and "Pong". Both
 392:shared.c      ****  * will run forever.
 393:shared.c      ****  */
 394:shared.c      **** int main() {
 605               		.loc 1 394 0
 606               		.cfi_startproc
 607               	/* prologue: function */
 608               	/* frame size = 0 */
 609               	/* stack size = 0 */
 610               	.L__stack_usage = 0
 395:shared.c      ****   DDRB = (1<<PB7); // INIT PIN 13
 611               		.loc 1 395 0
 612 0000 80E8      		ldi r24,lo8(-128)
 613 0002 84B9      		out 0x4,r24
 396:shared.c      ****   DDRL = (1<<PB3) + (1<<PB2);
 614               		.loc 1 396 0
 615 0004 8CE0      		ldi r24,lo8(12)
 616 0006 8093 0A01 		sts 266,r24
 397:shared.c      ****   OS_Init();
 617               		.loc 1 397 0
 618 000a 0E94 0000 		call OS_Init
 619               	.LVL33:
 620               	.LBB12:
 621               	.LBB13:
 282:shared.c      ****   Kernel_Create_Task( f );
 622               		.loc 1 282 0
 623               	/* #APP */
 624               	 ;  282 "shared.c" 1
 625 000e F894      		cli
 626               	 ;  0 "" 2
 283:shared.c      ****   Enable_Interrupt();
 627               		.loc 1 283 0
 628               	/* #NOAPP */
 629 0010 80E0      		ldi r24,lo8(gs(Pong))
 630 0012 90E0      		ldi r25,hi8(gs(Pong))
 631 0014 0E94 0000 		call Kernel_Create_Task
 632               	.LVL34:
 284:shared.c      **** }
 633               		.loc 1 284 0
 634               	/* #APP */
 635               	 ;  284 "shared.c" 1
 636 0018 7894      		sei
 637               	 ;  0 "" 2
 638               	.LVL35:
 639               	/* #NOAPP */
 640               	.LBE13:
 641               	.LBE12:
 642               	.LBB14:
 643               	.LBB15:
 282:shared.c      ****   Kernel_Create_Task( f );
 644               		.loc 1 282 0
 645               	/* #APP */
 646               	 ;  282 "shared.c" 1
 647 001a F894      		cli
 648               	 ;  0 "" 2
 283:shared.c      ****   Enable_Interrupt();
 649               		.loc 1 283 0
 650               	/* #NOAPP */
 651 001c 80E0      		ldi r24,lo8(gs(Ping))
 652 001e 90E0      		ldi r25,hi8(gs(Ping))
 653 0020 0E94 0000 		call Kernel_Create_Task
 654               	.LVL36:
 284:shared.c      **** }
 655               		.loc 1 284 0
 656               	/* #APP */
 657               	 ;  284 "shared.c" 1
 658 0024 7894      		sei
 659               	 ;  0 "" 2
 660               	/* #NOAPP */
 661               	.LBE15:
 662               	.LBE14:
 398:shared.c      ****   Task_Create( Pong );
 399:shared.c      ****   Task_Create( Ping );
 400:shared.c      ****   init_timer();
 663               		.loc 1 400 0
 664 0026 0E94 0000 		call init_timer
 665               	.LVL37:
 666               	.LBB16:
 667               	.LBB17:
 266:shared.c      ****                 Disable_Interrupt();
 668               		.loc 1 266 0
 669 002a 8091 0000 		lds r24,KernelActive
 670 002e 9091 0000 		lds r25,KernelActive+1
 671 0032 892B      		or r24,r25
 672 0034 01F0      		breq .L62
 673               	.L64:
 674               	.L65:
 675 0036 00C0      		rjmp .L65
 676               	.L62:
 677 0038 8091 0000 		lds r24,Tasks
 678 003c 9091 0000 		lds r25,Tasks+1
 679 0040 892B      		or r24,r25
 680 0042 01F0      		breq .L64
 267:shared.c      **** 
 681               		.loc 1 267 0
 682               	/* #APP */
 683               	 ;  267 "shared.c" 1
 684 0044 F894      		cli
 685               	 ;  0 "" 2
 270:shared.c      ****                 asm ( "jmp Exit_Kernel" :: );
 686               		.loc 1 270 0
 687               	/* #NOAPP */
 688 0046 81E0      		ldi r24,lo8(1)
 689 0048 90E0      		ldi r25,0
 690 004a 9093 0000 		sts KernelActive+1,r25
 691 004e 8093 0000 		sts KernelActive,r24
 271:shared.c      ****         }
 692               		.loc 1 271 0
 693               	/* #APP */
 694               	 ;  271 "shared.c" 1
 695 0052 0C94 0000 		jmp Exit_Kernel
 696               	 ;  0 "" 2
 697               	/* #NOAPP */
 698 0056 00C0      		rjmp .L64
 699               	.LBE17:
 700               	.LBE16:
 701               		.cfi_endproc
 702               	.LFE18:
 704               		.text
 705               	.global	__vector_17
 707               	__vector_17:
 708               	.LFB19:
 401:shared.c      ****   OS_Start();
 402:shared.c      ****   while (1) {}
 403:shared.c      ****   return 0;
 404:shared.c      **** }
 405:shared.c      **** 
 406:shared.c      **** ISR(TIMER1_COMPA_vect) {
 709               		.loc 1 406 0
 710               		.cfi_startproc
 711 0298 1F92      		push r1
 712               	.LCFI0:
 713               		.cfi_def_cfa_offset 4
 714               		.cfi_offset 1, -3
 715 029a 0F92      		push r0
 716               	.LCFI1:
 717               		.cfi_def_cfa_offset 5
 718               		.cfi_offset 0, -4
 719 029c 0FB6      		in r0,__SREG__
 720 029e 0F92      		push r0
 721 02a0 1124      		clr __zero_reg__
 722 02a2 0BB6      		in r0,__RAMPZ__
 723 02a4 0F92      		push r0
 724 02a6 2F93      		push r18
 725               	.LCFI2:
 726               		.cfi_def_cfa_offset 6
 727               		.cfi_offset 18, -5
 728 02a8 3F93      		push r19
 729               	.LCFI3:
 730               		.cfi_def_cfa_offset 7
 731               		.cfi_offset 19, -6
 732 02aa 4F93      		push r20
 733               	.LCFI4:
 734               		.cfi_def_cfa_offset 8
 735               		.cfi_offset 20, -7
 736 02ac 5F93      		push r21
 737               	.LCFI5:
 738               		.cfi_def_cfa_offset 9
 739               		.cfi_offset 21, -8
 740 02ae 6F93      		push r22
 741               	.LCFI6:
 742               		.cfi_def_cfa_offset 10
 743               		.cfi_offset 22, -9
 744 02b0 7F93      		push r23
 745               	.LCFI7:
 746               		.cfi_def_cfa_offset 11
 747               		.cfi_offset 23, -10
 748 02b2 8F93      		push r24
 749               	.LCFI8:
 750               		.cfi_def_cfa_offset 12
 751               		.cfi_offset 24, -11
 752 02b4 9F93      		push r25
 753               	.LCFI9:
 754               		.cfi_def_cfa_offset 13
 755               		.cfi_offset 25, -12
 756 02b6 AF93      		push r26
 757               	.LCFI10:
 758               		.cfi_def_cfa_offset 14
 759               		.cfi_offset 26, -13
 760 02b8 BF93      		push r27
 761               	.LCFI11:
 762               		.cfi_def_cfa_offset 15
 763               		.cfi_offset 27, -14
 764 02ba EF93      		push r30
 765               	.LCFI12:
 766               		.cfi_def_cfa_offset 16
 767               		.cfi_offset 30, -15
 768 02bc FF93      		push r31
 769               	.LCFI13:
 770               		.cfi_def_cfa_offset 17
 771               		.cfi_offset 31, -16
 772               	/* prologue: Signal */
 773               	/* frame size = 0 */
 774               	/* stack size = 16 */
 775               	.L__stack_usage = 16
 407:shared.c      ****   Task_Next();
 776               		.loc 1 407 0
 777 02be 0E94 0000 		call Task_Next
 778               	.LVL38:
 779               	/* epilogue start */
 408:shared.c      **** }
 780               		.loc 1 408 0
 781 02c2 FF91      		pop r31
 782 02c4 EF91      		pop r30
 783 02c6 BF91      		pop r27
 784 02c8 AF91      		pop r26
 785 02ca 9F91      		pop r25
 786 02cc 8F91      		pop r24
 787 02ce 7F91      		pop r23
 788 02d0 6F91      		pop r22
 789 02d2 5F91      		pop r21
 790 02d4 4F91      		pop r20
 791 02d6 3F91      		pop r19
 792 02d8 2F91      		pop r18
 793 02da 0F90      		pop r0
 794 02dc 0BBE      		out __RAMPZ__,r0
 795 02de 0F90      		pop r0
 796 02e0 0FBE      		out __SREG__,r0
 797 02e2 0F90      		pop r0
 798 02e4 1F90      		pop r1
 799 02e6 1895      		reti
 800               		.cfi_endproc
 801               	.LFE19:
 803               		.local	Tasks
 804               		.comm	Tasks,2,1
 805               		.local	KernelActive
 806               		.comm	KernelActive,2,1
 807               		.local	NextP
 808               		.comm	NextP,2,1
 809               		.comm	CurrentP,2,1
 810               		.local	Process
 811               		.comm	Process,1036,1
 812               	.global	elapsed
 813               		.section .bss
 816               	elapsed:
 817 0000 0000 0000 		.zero	4
 818               		.text
 819               	.Letext0:
 820               		.file 2 "/usr/lib/avr/include/stdint.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 shared.c
     /tmp/ccOZt9OS.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/ccOZt9OS.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/ccOZt9OS.s:4      *ABS*:000000000000003f __SREG__
     /tmp/ccOZt9OS.s:5      *ABS*:000000000000003b __RAMPZ__
     /tmp/ccOZt9OS.s:6      *ABS*:0000000000000000 __tmp_reg__
     /tmp/ccOZt9OS.s:7      *ABS*:0000000000000001 __zero_reg__
     /tmp/ccOZt9OS.s:13     .text:0000000000000000 Ping
     /tmp/ccOZt9OS.s:41     .text:000000000000000e Pong
     /tmp/ccOZt9OS.s:68     .text:000000000000001c Task_Terminate
     /tmp/ccOZt9OS.s:804    .bss:0000000000000006 KernelActive
                            *COM*:0000000000000002 CurrentP
     /tmp/ccOZt9OS.s:110    .text:000000000000003e Kernel_Create_Task_At
     /tmp/ccOZt9OS.s:178    .text:0000000000000084 Kernel_Create_Task
                             .bss:0000000000000004 Tasks
     /tmp/ccOZt9OS.s:808    .bss:000000000000000a Process
     /tmp/ccOZt9OS.s:244    .text:00000000000000e2 signal_start_task
     /tmp/ccOZt9OS.s:302    .text:0000000000000130 Dispatch
     /tmp/ccOZt9OS.s:806    .bss:0000000000000008 NextP
     /tmp/ccOZt9OS.s:379    .text:00000000000001c0 OS_Init
     /tmp/ccOZt9OS.s:432    .text:0000000000000202 OS_Start
     /tmp/ccOZt9OS.s:474    .text:000000000000022e Task_Create
     /tmp/ccOZt9OS.s:504    .text:0000000000000238 Task_Next
     /tmp/ccOZt9OS.s:547    .text:0000000000000260 init_timer
     /tmp/ccOZt9OS.s:603    .text.startup:0000000000000000 main
     /tmp/ccOZt9OS.s:707    .text:0000000000000298 __vector_17
     /tmp/ccOZt9OS.s:816    .bss:0000000000000000 elapsed

UNDEFINED SYMBOLS
Exit_Kernel
CSwitch
__do_clear_bss
